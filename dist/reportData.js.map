{"version":3,"sources":["../src/reportData.js"],"names":["_","ScrutinizerJSON","scrut","options","reportFilter","query","authToken","reportType","reportDirection","reportDisplay","scrutDisplay","display","startTime","unix","endTime","scrutFilters","selectedGranularity","reportGranularity","Number","isInteger","parseInt","reportInterface","target","reportFilters","exporterInterface","sdfDips_0","filterJson","JSON","parse","key","hasOwnProperty","filterObject","sourceIp","length","forEach","element","index","filerCount","destIp","ports","exporterDetails","exporterIp","interfaceId","filterCount","scrutInfo","url","method","params","rm","type","exporter","action","str","defaultGroupOnTop","statusTreeEnabled","page","scrutParams","report_data","stringify","reportDirections","selected","reportTypeLang","times","dateRange","start","end","clientTimezone","filters","dataGranularity","oneCollectorRequest","ipAddress","groupName","view","session_state","exporterName","client_time_zone","order_by","search","column","value","comparison","data","_key","query_limit","offset","max_num_rows","hostDisplayType","entityName","entity_id","entityType","reportEntity","rmTypes","applications","protocols","srcIPGroups","dstIPGroups","srcHosts","dstHosts","app_id","st","et","src","dst","rpt_json","orderBy","showOthers","data_requested","graph","table","Handledata","rearrangeData","arr","oldIndex","newIndex","old_index","new_index","k","push","undefined","splice","entity","entityLabel","entityChosen","targetLabel","dataToGraph","String","datapoints","bytesTotal","entityData","graphPoint","pointInTime","scrutData","graphGranularity","dnsResolve","reportDNS","graphRes","displayValue","datatoGraph","graphingData","i","j","graphData","tableData","Math","round","interfaceDesc"],"mappings":"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","file":"reportData.js","sourcesContent":["import _ from \"lodash\";\r\n\r\n\r\nexport class ScrutinizerJSON {\r\n  constructor() {}\r\n  createFilters (scrut, options, reportFilter,query){\r\n    let {authToken} = scrut;\r\n    let {reportType, reportDirection,reportDisplay } = query\r\n    let scrutDisplay;\r\n    if (reportDisplay === \"percent\") {\r\n      scrutDisplay = { display: \"custom_interfacepercent\" };\r\n    } else {\r\n      scrutDisplay = { display: \"sum_octetdeltacount\" };\r\n    }\r\n    return {\r\n      authToken,\r\n      reportType,\r\n      startTime: options[\"range\"][\"from\"].unix(),\r\n      endTime: options[\"range\"][\"to\"].unix(),\r\n      reportDirection,\r\n      scrutDisplay,\r\n      scrutFilters : reportFilter\r\n\r\n    }\r\n\r\n  }\r\n// used for single query\r\n  createParams (scrut, options, query) {\r\n\r\n    let selectedGranularity = query.reportGranularity\r\n\r\n    if(!Number.isInteger(parseInt(selectedGranularity))) {\r\n      selectedGranularity = 'auto'\r\n    }\r\n    \r\n    let {authToken} = scrut;\r\n    let {reportType, reportDirection,reportInterface, target, reportFilters, reportDisplay} = query\r\n    let startTime = options[\"range\"][\"from\"].unix()\r\n    let endTime = options[\"range\"][\"to\"].unix()\r\n    let scrutFilters;\r\n    let exporterInterface;\r\n    let scrutDisplay;\r\n    if (reportInterface === \"allInterfaces\") {\r\n      exporterInterface = \"_ALL\";\r\n    } else {\r\n      exporterInterface = reportInterface;\r\n    }\r\n\r\n    //  if user wants all devices, then they are defualted to all interfaces\r\n    if (target === \"allExporters\") {\r\n      scrutFilters = {\r\n        sdfDips_0: `in_GROUP_ALL`\r\n      };\r\n    } else if (target === \"deviceGroup\") {\r\n      scrutFilters = {\r\n        sdfDips_0: `in_GROUP_${exporterInterface}`\r\n      };\r\n    } else {\r\n      // if user wants a specific device, they can either have ALL interfaces, or a specific interface\r\n      if (exporterInterface === \"_ALL\") {\r\n        scrutFilters = {\r\n          sdfDips_0: `in_${target}_ALL`\r\n        };\r\n      } else {\r\n        scrutFilters = {\r\n          sdfDips_0: `in_${target}_${target}-${exporterInterface}`\r\n        };\r\n      }\r\n    }\r\n\r\n    \r\n    if (reportFilters !== \"No Filter\") {\r\n      let filterJson = JSON.parse(reportFilters);\r\n      for (var key in filterJson) {\r\n        if (filterJson.hasOwnProperty(key)) {\r\n          if (key != \"sdfDips_0\") {\r\n            scrutFilters[key] = filterJson[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (reportDisplay === \"percent\") {\r\n      scrutDisplay = { display: \"custom_interfacepercent\" };\r\n    } else {\r\n      scrutDisplay = { display: \"sum_octetdeltacount\" };\r\n    }\r\n\r\n\r\n\r\n    return {\r\n        authToken,\r\n        reportType,\r\n        startTime,\r\n        endTime,\r\n        reportDirection,\r\n        scrutFilters,\r\n        scrutDisplay,\r\n        selectedGranularity\r\n       \r\n  \r\n      }\r\n    \r\n     \r\n\r\n\r\n  }\r\n\r\n// cused to create filter object for adhoc queries\r\ncreateAdhocFilters(filterObject) {\r\n\r\n  let reportFilters = {};\r\n\r\n  //if there are ip addres filters, add them\r\n  if (filterObject.sourceIp.length > 0) {\r\n    filterObject.sourceIp.forEach((element, index) => {\r\n      let filerCount = `sdfIps_${index}`;\r\n      reportFilters[filerCount] = `in_${element}_src`;\r\n    });\r\n  }\r\n\r\n  if (filterObject.destIp.length > 0) {\r\n    filterObject.destIp.forEach((element, index) => {\r\n      let filerCount = `sdfIps_${index}`;\r\n      reportFilters[filerCount] = `in_${element}_dst`;\r\n    });\r\n  }\r\n\r\n  if (filterObject.ports.length > 0) {\r\n    filterObject.ports.forEach((element, index) => {\r\n      let filerCount = `sdfSdPorts_${index}`;\r\n      reportFilters[filerCount] = `in_${element}_both`;\r\n    });\r\n  }\r\n  //there will always be exporter filters, add them.\r\n  filterObject.exporterDetails.forEach((element, index) => {\r\n    \r\n    let { exporterIp, interfaceId } = element;\r\n\r\n    let filterCount = `sdfDips_${index}`;\r\n    if(exporterIp === \"GROUP\"){\r\n      reportFilters[filterCount] = `in_${exporterIp}_${interfaceId}`\r\n    }else if (exporterIp === \"ALL\"){\r\n      reportFilters[filterCount] = `in_${exporterIp}_${interfaceId}`\r\n    } else if (interfaceId != \"ALL\")\r\n    {\r\n      reportFilters[filterCount] = `in_${exporterIp}_${exporterIp}-${interfaceId}`;\r\n    }else if (exporterIp != \"ALL\" && exporterIp != \"GROUP\"){\r\n      reportFilters[filterCount] = `in_${exporterIp}_${interfaceId}`\r\n    }\r\n    \r\n  });\r\n \r\n\r\n  return reportFilters;\r\n}\r\n  \r\n  authJson(scrutInfo){\r\n    return {\r\n      url: scrutInfo['url'],\r\n      method: \"GET\",\r\n      params:{\r\n        rm: \"licensing\",\r\n        authToken:scrutInfo['authToken']\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  exporterJSON(scrutInfo) {\r\n    //params to figure out which exporters are available to pick from.\r\n    return {\r\n      url: scrutInfo['url'],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"get_known_objects\",\r\n        type: \"devices\",\r\n        authToken: scrutInfo['authToken']\r\n      }\r\n    };\r\n  };\r\n\r\n  findExporter(scrutInfo, exporter) {\r\n    \r\n    return {\r\n      url: scrutInfo[\"url\"],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"loadMap\",\r\n        action: \"search\",\r\n        str: exporter,\r\n        authToken: scrutInfo[\"authToken\"],\r\n        defaultGroupOnTop: 1,\r\n        statusTreeEnabled: 1,\r\n        page: 1\r\n      }\r\n    };\r\n  };\r\n\r\n  findtimeJSON(scrutInfo,scrutParams,query) {\r\n\r\n    let selectedGranularity = query.reportGranularity\r\n\r\n    if(!Number.isInteger(parseInt(selectedGranularity))) {\r\n      selectedGranularity = 'auto'\r\n    }\r\n    \r\n\r\n    //params to figure out which interval your in based on data you are requesting\r\n    return {\r\n      url:scrutInfo['url'],\r\n      method:'get',\r\n      params:{\r\n        rm: \"report_start\",\r\n        authToken: scrutInfo['authToken'],\r\n        report_data: JSON.stringify({\r\n          parse: true,\r\n          reportDirections: { selected: `${scrutParams.reportDirection}` },\r\n          reportTypeLang: `${scrutParams.reportType}`,\r\n          times: {\r\n            dateRange: \"Custom\",\r\n            start: `${scrutParams.startTime}`,\r\n            end: `${scrutParams.endTime}`,\r\n            clientTimezone: \"America/New_York\"\r\n          },\r\n          filters: scrutParams.scrutFilters,\r\n          dataGranularity: { selected: selectedGranularity },\r\n          oneCollectorRequest: false\r\n        })\r\n      },\r\n\r\n    };\r\n  };\r\n\r\n  groupJSON(url, authToken) {\r\n    return {\r\n      url,\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"get_known_objects\",\r\n        type: \"deviceGroups\",\r\n        authToken\r\n      }\r\n    };\r\n  };\r\n\r\n  interfaceJSON(scrutInfo, ipAddress) {\r\n \r\n    \r\n    if(ipAddress['key'] ===\"Device Group\"){\r\n      let groupName = ipAddress['value']\r\n      return {\r\n        url: scrutInfo['url'],\r\n        method:\"get\",\r\n        \r\n\r\n        params: {\r\n          rm: \"mappingConfiguration\",\r\n          view: \"mapping_configuration\",\r\n          authToken: scrutInfo[\"authToken\"],\r\n          session_state:{\r\n            \"client_time_zone\":\"America/New_York\",\"order_by\":[],\r\n            \"search\":[\r\n              {\r\n                \"column\":\"name\",\r\n                \"value\":groupName,\r\n                \"comparison\":\"equal\",\r\n                \"data\":\r\n                  {\"filterType\":\"string\"},\"_key\":\"name_equal_Cisco\"}\r\n                ],\r\n            \"query_limit\":{\r\n              \"offset\":0,\"max_num_rows\":50},\"hostDisplayType\":\"dns\"}\r\n          }\r\n        }\r\n    } else {\r\n      let exporterName\r\n      if (ipAddress['value']) {\r\n        exporterName = ipAddress['value']\r\n      } else {\r\n        exporterName = ipAddress\r\n      }\r\n      \r\n   \r\n      return {\r\n        url: scrutInfo[\"url\"],\r\n        method: \"get\",\r\n        params: {\r\n          rm: \"status\",\r\n          action: \"get\",\r\n          view: \"topInterfaces\",\r\n          authToken: scrutInfo[\"authToken\"],\r\n          session_state: JSON.stringify({\r\n            client_time_zone: \"America/New_York\",\r\n            order_by: [],\r\n            search: [\r\n              {\r\n                column: \"exporter_search\",\r\n                value: ` ${exporterName} `,\r\n                comparison: \"like\",\r\n                data: { },\r\n                _key: `exporter_search_like_ ${exporterName} `\r\n              }\r\n            ],\r\n            query_limit: { offset: 0, max_num_rows: 50 },\r\n            hostDisplayType: \"ip\"\r\n          })\r\n        }\r\n      };\r\n    }\r\n    \r\n\r\n    };\r\n    \r\n   \r\n   \r\n\r\n  getAllEntities(scrutInfo, entityName) {\r\n\r\n    //both of these comes back in the 'hosts' runmode. But I need something specific in order to pull time series for them. Will have to do the same for IpGroups, countries, and AS. \r\n    if (entityName === 'srcHosts' || entityName === 'dstHosts'){\r\n      entityName = 'hosts'\r\n    }\r\n      return {\r\n        url:scrutInfo['url'],\r\n        method: \"GET\",\r\n        params: {\r\n          rm: \"status\",\r\n          view: entityName,\r\n          authToken: scrutInfo[\"authToken\"]\r\n        }\r\n      };\r\n    };\r\n  \r\n  \r\n  getEntityTimeseries(scrutInfo,entity_id, options, query){\r\n    \r\n\r\n  \r\n    let entityType = query.reportEntity\r\n    \r\n    //come from the Grafana time range selected. \r\n    let startTime = options[\"range\"][\"from\"].unix()\r\n    let endTime = options[\"range\"][\"to\"].unix()\r\n    \r\n    let rmTypes = {\r\n      applications:\"alarmsEntityApplication\",\r\n      protocols:\"alarmsEntityProtocol\",\r\n      srcIPGroups: \"alarmsEntityIPGroup\",\r\n      dstIPGroups: \"alarmsEntityIPGroup\",\r\n      srcHosts: \"alarmsEntityHost\",\r\n      dstHosts:\"alarmsEntityHost\"\r\n    }\r\n   \r\n    // each of the entities takes sliglty different params to get the data back - so we create them depending on what the Entity_ID is. \r\n\r\n    if (entityType === 'applications')\r\n    {\r\n      return {\r\n        url:scrutInfo['url'],\r\n        method: \"GET\",\r\n        params: {\r\n          rm: rmTypes[entityType],\r\n          view: \"load\",\r\n          authToken: scrutInfo[\"authToken\"],\r\n          app_id:entity_id,\r\n          st:startTime,\r\n          et:endTime\r\n        }\r\n      };\r\n    } else if(entityType === 'protocols') {\r\n      //protocals is a bit wierd, there isn't a way to specify a specific one, so you get them all back and figure it out later. \r\n      return {\r\n        url:scrutInfo['url'],\r\n        method: \"GET\",\r\n        params: {\r\n          rm: rmTypes[entityType],\r\n          view: \"load\",\r\n          authToken: scrutInfo[\"authToken\"],\r\n          st:startTime,\r\n          et:endTime\r\n        }\r\n      }\r\n    }else if(entityType === 'srcHosts') {\r\n      return {\r\n        url:scrutInfo['url'],\r\n        method: \"GET\",\r\n        params: {\r\n          rm: rmTypes[entityType],\r\n          view: \"trend\",\r\n          authToken: scrutInfo[\"authToken\"],\r\n          src:entity_id,\r\n          st:startTime,\r\n          et:endTime\r\n        }\r\n      }\r\n    }else if(entityType === 'dstHosts') {\r\n      return {\r\n        url:scrutInfo['url'],\r\n        method: \"GET\",\r\n        params: {\r\n          rm: rmTypes[entityType],\r\n          view: \"trend\",\r\n          authToken: scrutInfo[\"authToken\"],\r\n          dst:entity_id,\r\n          st:startTime,\r\n          et:endTime\r\n        }\r\n      }\r\n    }\r\n    \r\n\r\n\r\n\r\n        \r\n\r\n       \r\n    } \r\n\r\n  \r\n\r\n\r\n \r\n\r\n  reportJSON(scrutInfo, scrutParams) {\r\n\r\n    let selectedGranularity = scrutParams.selectedGranularity\r\n    //returning report params to be passed into request\r\n    return {\r\n      url:scrutInfo['url'],\r\n      'method':'get',\r\n      params:{\r\n        rm: \"report_api\",\r\n        action: \"get\",\r\n        authToken: scrutInfo['authToken'],\r\n        rpt_json: JSON.stringify({\r\n          reportTypeLang: scrutParams.reportType,\r\n          reportDirections: {\r\n            selected: scrutParams.reportDirection\r\n          },\r\n          times: {\r\n            dateRange: \"Custom\",\r\n            start: `${scrutParams.startTime}`,\r\n            end: `${scrutParams.endTime}`\r\n          },\r\n          orderBy: scrutParams.scrutDisplay[\"display\"],\r\n          filters: scrutParams.scrutFilters,\r\n          dataGranularity: {\r\n            selected: selectedGranularity\r\n          },\r\n          showOthers: 0\r\n        }),\r\n  \r\n        data_requested: JSON.stringify({\r\n          [scrutParams.reportDirection]: {\r\n            graph: \"all\",\r\n            table: {\r\n              query_limit: {\r\n                offset: 0,\r\n                max_num_rows: 10\r\n              }\r\n            }\r\n          }\r\n        })\r\n      }\r\n\r\n    };\r\n  }  \r\n\r\n}\r\nexport class Handledata {\r\n  //scrutinizer returns graph data opposite of how grafana wants it. So we flip it here.\r\n  constructor() {\r\n    this.rearrangeData = (arr, oldIndex, newIndex) => {\r\n      while (oldIndex < 0) {\r\n        old_index += arr.length;\r\n      }\r\n      while (newIndex < 0) {\r\n        new_index += arr.length;\r\n      }\r\n      if (newIndex >= arr.length) {\r\n        let k = newIndex - arr.length;\r\n\r\n        while (k-- + 1) {\r\n          arr.push(undefined);\r\n        }\r\n      }\r\n      arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\r\n      return arr;\r\n    };\r\n  }\r\n\r\n\r\n\r\n  formatEntityData(entity, entityLabel, entityChosen){\r\n    let targetLabel\r\n    if(entityChosen === 'srcHosts'){\r\n      targetLabel = 'Src_' + entityLabel\r\n    }else if (entityChosen === 'dstHosts'){\r\n      targetLabel =  'Dst_' + entityLabel\r\n    }else{\r\n      targetLabel = entityLabel\r\n    }\r\n    let dataToGraph = {\r\n      target:String(targetLabel),\r\n      datapoints:[],\r\n      bytesTotal: 0\r\n    }\r\n\r\n    let entityData = entity['data']['trend']\r\n \r\n    if(entityChosen === 'applications'){ \r\n      entityData.forEach((graphPoint)=>{\r\n\r\n     \r\n        let pointInTime = [parseInt(graphPoint['bytes']),(graphPoint['ts'] * 1000)]\r\n  \r\n        dataToGraph['datapoints'].push(pointInTime)\r\n        dataToGraph['bytesTotal'] = dataToGraph['bytesTotal'] += parseInt(graphPoint['bytes'])\r\n      })\r\n    } else if (entityChosen === 'protocols') {\r\n\r\n\r\n      entityData.forEach((graphPoint)=>{\r\n        if(graphPoint['name']===entityLabel){\r\n          let pointInTime = [parseInt(graphPoint['bytes']),(graphPoint['ts'] * 1000)]\r\n          dataToGraph['datapoints'].push(pointInTime)\r\n          dataToGraph['bytesTotal'] = dataToGraph['bytesTotal'] += parseInt(graphPoint['bytes'])\r\n        }\r\n\r\n      })\r\n\r\n    }\r\n\r\n    else if (entityChosen === 'srcHosts'){\r\n      entityData.forEach((graphPoint)=>{\r\n        if(graphPoint['src']===entityLabel){\r\n          let pointInTime = [parseInt(graphPoint['src_bytes']),(graphPoint['ts'] * 1000)]\r\n  \r\n          dataToGraph['datapoints'].push(pointInTime)\r\n          dataToGraph['bytesTotal'] = dataToGraph['bytesTotal'] += parseInt(graphPoint['src_bytes'])\r\n        }\r\n\r\n      })\r\n    }\r\n    else if (entityChosen === 'dstHosts'){\r\n      entityData.forEach((graphPoint)=>{\r\n        if(graphPoint['dst']===entityLabel){\r\n          let pointInTime = [parseInt(graphPoint['dst_bytes']),(graphPoint['ts'] * 1000)]\r\n  \r\n          dataToGraph['datapoints'].push(pointInTime)\r\n          dataToGraph['bytesTotal'] = dataToGraph['bytesTotal'] += parseInt(graphPoint['dst_bytes'])\r\n        }\r\n\r\n      })\r\n    }   \r\n\r\n    return dataToGraph\r\n  }\r\n\r\n  formatData(scrutData, scrutParams, graphGranularity, options) {\r\n \r\n    //check if DNS resolve is on. \r\n    let dnsResolve = options.reportDNS\r\n\r\n\r\n    let graphRes = parseInt(graphGranularity) / 60\r\n\r\n    let displayValue;\r\n\r\n    if (scrutParams.scrutDisplay[\"display\"] === \"custom_interfacepercent\") {\r\n      displayValue = \"percent\";\r\n    } else {\r\n      displayValue = \"bits\";\r\n    }\r\n\r\n    let reportDirection = scrutParams.reportDirection;\r\n    //grafana wants time in millaseconds. so we multiple by 1000.\r\n    //we also want to return data in bits, so we device by 8\r\n    let datatoGraph = [];\r\n\r\n    let graphingData = scrutData;\r\n    let i,\r\n      j = 0;\r\n    let graphData = graphingData[\"report\"][\"graph\"][\"pie\"][reportDirection];\r\n\r\n    let tableData =\r\n      graphingData[\"report\"][\"graph\"][\"timeseries\"][reportDirection];\r\n\r\n    //if user is selecting bits, we need to multiple by 8, we also need to use the interval time.\r\n    if (displayValue === \"bits\") {\r\n      for (i = 0; i < tableData.length; i++) {\r\n        for (j = 0; j < tableData[i].length; j++) {\r\n          tableData[i][j][0] = tableData[i][j][0] * 1000;\r\n          tableData[i][j][1] = (tableData[i][j][1] * 8) / (graphRes * 60);\r\n          this.rearrangeData(tableData[i][j], 0, 1);\r\n        }\r\n      }\r\n    } else {\r\n      //since interface reporting uses the total tables, we dont need to math it.\r\n      for (i = 0; i < tableData.length; i++) {\r\n        for (j = 0; j < tableData[i].length; j++) {\r\n          tableData[i][j][0] = tableData[i][j][0] * 1000;\r\n          tableData[i][j][1] = Math.round(tableData[i][j][1]);\r\n          this.rearrangeData(tableData[i][j], 0, 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < graphData.length; i++) {\r\n\r\n      let interfaceId;\r\n      let interfaceDesc;\r\n\r\n      if (scrutParams[\"reportType\"] === \"interfaces\") {\r\n        if (scrutParams[\"reportDirection\"] === \"inbound\") {\r\n          interfaceId = \"Inbound Interface\";\r\n          interfaceDesc = \"Inbound\";\r\n        } else {\r\n          interfaceId = \"Outbound Interface\";\r\n          interfaceDesc = \"Outbound\";\r\n        }\r\n        //scrutinizer returns a small amout of \"other traffic\" for interface reporting\r\n        //this has to do with the relationship between totals and conversations.\r\n        //we don't need this data, so we toss it out. It makes it do we can use SingleStat\r\n        //and Guage visualizations for interfaces, which is nice.\r\n       \r\n        if (graphData[i][\"label\"] != \"Other\") {\r\n          //check to make sure there is utilization data for interfaces.\r\n          if(tableData[i]){\r\n            datatoGraph.push({\r\n              target:\r\n                interfaceDesc + \"--\" + graphData[i][\"tooltip\"][1][interfaceId],\r\n              datapoints: tableData[i]\r\n            });\r\n          }\r\n\r\n          \r\n        }\r\n      } else {\r\n\r\n        if(!dnsResolve) {\r\n          datatoGraph.push({\r\n            target: graphData[i][\"label\"],\r\n            datapoints: tableData[i]\r\n          });\r\n        } else {\r\n          datatoGraph.push({\r\n            target: graphData[i][\"label_dns\"],\r\n            datapoints: tableData[i]\r\n          });\r\n        }\r\n\r\n\r\n\r\n      }\r\n    }\r\n\r\n    return datatoGraph\r\n    \r\n  }\r\n}\r\n\r\n"]}