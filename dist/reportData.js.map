{"version":3,"sources":["../src/reportData.js"],"names":["_","sum","moment","ScrutinizerJSON","scrut","options","reportFilter","query","authToken","reportType","reportDirection","reportDisplay","scrutDisplay","display","startTime","unix","endTime","scrutFilters","reportInterface","target","reportFilters","exporterInterface","sdfDips_0","filterJson","JSON","parse","key","hasOwnProperty","filterObject","sourceIp","length","forEach","element","index","filerCount","destIp","ports","exporterDetails","exporterIp","interfaceId","filterCount","scrutInfo","url","method","params","rm","type","exporter","action","str","defaultGroupOnTop","statusTreeEnabled","page","scrutParams","report_data","stringify","reportDirections","selected","reportTypeLang","times","dateRange","start","end","clientTimezone","filters","dataGranularity","oneCollectorRequest","ipAddress","groupName","view","session_state","exporterName","client_time_zone","order_by","search","column","value","comparison","data","_key","query_limit","offset","max_num_rows","hostDisplayType","rpt_json","orderBy","showOthers","data_requested","graph","table","forcastID","forecast_id","Handledata","rearrangeData","arr","oldIndex","newIndex","old_index","new_index","k","push","undefined","splice","scrutData","intervalTime","dnsResolve","reportDNS","displayValue","datatoGraph","graphingData","i","j","graphData","tableData","Math","round","interfaceDesc","datapoints","forcastData","forcastSummary","summaryData","summaryDataArray","summaryRow","itemInSummaryRow","keyToCheck","Object","keys","includes","rowLabel","rankValue","forcastResults","forcastItems","row","uniqueItems","Array","from","Set","finalSummaryData","testData","item","summaryItem","replacedItem","replace","e","forcestedItem","epochTime","valueOf","meanValue","parseInt","upperValue","lowerValue","err","console","log","forecasteData","allForcastList","allForecasts","forcastObject","forecast","forecastId","toString","forecastDescription"],"mappings":"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","file":"reportData.js","sourcesContent":["import _, { sum } from \"lodash\";\r\nimport moment from \"moment\";\r\n\r\n\r\nexport class ScrutinizerJSON {\r\n  constructor() {}\r\n  createFilters (scrut, options, reportFilter,query){\r\n    let {authToken} = scrut;\r\n    let {reportType, reportDirection,reportDisplay } = query\r\n    let scrutDisplay;\r\n    if (reportDisplay === \"percent\") {\r\n      scrutDisplay = { display: \"custom_interfacepercent\" };\r\n    } else {\r\n      scrutDisplay = { display: \"sum_octetdeltacount\" };\r\n    }\r\n    return {\r\n      authToken,\r\n      reportType,\r\n      startTime: options[\"range\"][\"from\"].unix(),\r\n      endTime: options[\"range\"][\"to\"].unix(),\r\n      reportDirection,\r\n      scrutDisplay,\r\n      scrutFilters : reportFilter\r\n\r\n    }\r\n\r\n  }\r\n// used for single query\r\n  createParams (scrut, options, query) {\r\n    let {authToken} = scrut;\r\n    let {reportType, reportDirection,reportInterface, target, reportFilters, reportDisplay} = query\r\n    let startTime = options[\"range\"][\"from\"].unix()\r\n    let endTime = options[\"range\"][\"to\"].unix()\r\n    let scrutFilters;\r\n    let exporterInterface;\r\n    let scrutDisplay;\r\n    if (reportInterface === \"allInterfaces\") {\r\n      exporterInterface = \"_ALL\";\r\n    } else {\r\n      exporterInterface = reportInterface;\r\n    }\r\n\r\n    //  if user wants all devices, then they are defualted to all interfaces\r\n    if (target === \"allExporters\") {\r\n      scrutFilters = {\r\n        sdfDips_0: `in_GROUP_ALL`\r\n      };\r\n    } else if (target === \"deviceGroup\") {\r\n      scrutFilters = {\r\n        sdfDips_0: `in_GROUP_${exporterInterface}`\r\n      };\r\n    } else {\r\n      // if user wants a specific device, they can either have ALL interfaces, or a specific interface\r\n      if (exporterInterface === \"_ALL\") {\r\n        scrutFilters = {\r\n          sdfDips_0: `in_${target}_ALL`\r\n        };\r\n      } else {\r\n        scrutFilters = {\r\n          sdfDips_0: `in_${target}_${target}-${exporterInterface}`\r\n        };\r\n      }\r\n    }\r\n\r\n    \r\n    if (reportFilters !== \"No Filter\") {\r\n      let filterJson = JSON.parse(reportFilters);\r\n      for (var key in filterJson) {\r\n        if (filterJson.hasOwnProperty(key)) {\r\n          if (key != \"sdfDips_0\") {\r\n            scrutFilters[key] = filterJson[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (reportDisplay === \"percent\") {\r\n      scrutDisplay = { display: \"custom_interfacepercent\" };\r\n    } else {\r\n      scrutDisplay = { display: \"sum_octetdeltacount\" };\r\n    }\r\n\r\n\r\n\r\n    return {\r\n        authToken,\r\n        reportType,\r\n        startTime,\r\n        endTime,\r\n        reportDirection,\r\n        scrutFilters,\r\n        scrutDisplay\r\n       \r\n  \r\n      }\r\n    \r\n     \r\n\r\n\r\n  }\r\n\r\n// cused to create filter object for adhoc queries\r\ncreateAdhocFilters(filterObject) {\r\n\r\n  let reportFilters = {};\r\n\r\n  //if there are ip addres filters, add them\r\n  if (filterObject.sourceIp.length > 0) {\r\n    filterObject.sourceIp.forEach((element, index) => {\r\n      let filerCount = `sdfIps_${index}`;\r\n      reportFilters[filerCount] = `in_${element}_src`;\r\n    });\r\n  }\r\n\r\n  if (filterObject.destIp.length > 0) {\r\n    filterObject.destIp.forEach((element, index) => {\r\n      let filerCount = `sdfIps_${index}`;\r\n      reportFilters[filerCount] = `in_${element}_dst`;\r\n    });\r\n  }\r\n\r\n  if (filterObject.ports.length > 0) {\r\n    filterObject.ports.forEach((element, index) => {\r\n      let filerCount = `sdfSdPorts_${index}`;\r\n      reportFilters[filerCount] = `in_${element}_both`;\r\n    });\r\n  }\r\n  //there will always be exporter filters, add them.\r\n  filterObject.exporterDetails.forEach((element, index) => {\r\n    \r\n    let { exporterIp, interfaceId } = element;\r\n\r\n    let filterCount = `sdfDips_${index}`;\r\n    if(exporterIp === \"GROUP\"){\r\n      reportFilters[filterCount] = `in_${exporterIp}_${interfaceId}`\r\n    }else if (exporterIp === \"ALL\"){\r\n      reportFilters[filterCount] = `in_${exporterIp}_${interfaceId}`\r\n    } else if (interfaceId != \"ALL\")\r\n    {\r\n      reportFilters[filterCount] = `in_${exporterIp}_${exporterIp}-${interfaceId}`;\r\n    }else if (exporterIp != \"ALL\" && exporterIp != \"GROUP\"){\r\n      reportFilters[filterCount] = `in_${exporterIp}_${interfaceId}`\r\n    }\r\n    \r\n  });\r\n \r\n\r\n  return reportFilters;\r\n}\r\n  \r\n  authJson(scrutInfo){\r\n    return {\r\n      url: scrutInfo['url'],\r\n      method: \"GET\",\r\n      params:{\r\n        rm: \"licensing\",\r\n        authToken:scrutInfo['authToken']\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  exporterJSON(scrutInfo) {\r\n    //params to figure out which exporters are available to pick from.\r\n    return {\r\n      url: scrutInfo['url'],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"get_known_objects\",\r\n        type: \"devices\",\r\n        authToken: scrutInfo['authToken']\r\n      }\r\n    };\r\n  };\r\n\r\n  findExporter(scrutInfo, exporter) {\r\n    \r\n    return {\r\n      url: scrutInfo[\"url\"],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"loadMap\",\r\n        action: \"search\",\r\n        str: exporter,\r\n        authToken: scrutInfo[\"authToken\"],\r\n        defaultGroupOnTop: 1,\r\n        statusTreeEnabled: 1,\r\n        page: 1\r\n      }\r\n    };\r\n  };\r\n\r\n  findtimeJSON(scrutInfo,scrutParams) {\r\n    //params to figure out which interval your in based on data you are requesting\r\n    return {\r\n      url:scrutInfo['url'],\r\n      method:'get',\r\n      params:{\r\n        rm: \"report_start\",\r\n        authToken: scrutInfo['authToken'],\r\n        report_data: JSON.stringify({\r\n          parse: true,\r\n          reportDirections: { selected: `${scrutParams.reportDirection}` },\r\n          reportTypeLang: `${scrutParams.reportType}`,\r\n          times: {\r\n            dateRange: \"Custom\",\r\n            start: `${scrutParams.startTime}`,\r\n            end: `${scrutParams.endTime}`,\r\n            clientTimezone: \"America/New_York\"\r\n          },\r\n          filters: scrutParams.scrutFilters,\r\n          dataGranularity: { selected: \"auto\" },\r\n          oneCollectorRequest: false\r\n        })\r\n      },\r\n\r\n    };\r\n  };\r\n\r\n  groupJSON(url, authToken) {\r\n    return {\r\n      url,\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"get_known_objects\",\r\n        type: \"deviceGroups\",\r\n        authToken\r\n      }\r\n    };\r\n  };\r\n\r\n  interfaceJSON(scrutInfo, ipAddress) {\r\n \r\n    \r\n    if(ipAddress['key'] ===\"Device Group\"){\r\n      let groupName = ipAddress['value']\r\n      return {\r\n        url: scrutInfo['url'],\r\n        method:\"get\",\r\n        \r\n\r\n        params: {\r\n          rm: \"mappingConfiguration\",\r\n          view: \"mapping_configuration\",\r\n          authToken: scrutInfo[\"authToken\"],\r\n          session_state:{\r\n            \"client_time_zone\":\"America/New_York\",\"order_by\":[],\r\n            \"search\":[\r\n              {\r\n                \"column\":\"name\",\r\n                \"value\":groupName,\r\n                \"comparison\":\"equal\",\r\n                \"data\":\r\n                  {\"filterType\":\"string\"},\"_key\":\"name_equal_Cisco\"}\r\n                ],\r\n            \"query_limit\":{\r\n              \"offset\":0,\"max_num_rows\":50},\"hostDisplayType\":\"dns\"}\r\n          }\r\n        }\r\n    } else {\r\n      let exporterName\r\n      if (ipAddress['value']) {\r\n        exporterName = ipAddress['value']\r\n      } else {\r\n        exporterName = ipAddress\r\n      }\r\n      \r\n   \r\n      return {\r\n        url: scrutInfo[\"url\"],\r\n        method: \"get\",\r\n        params: {\r\n          rm: \"status\",\r\n          action: \"get\",\r\n          view: \"topInterfaces\",\r\n          authToken: scrutInfo[\"authToken\"],\r\n          session_state: JSON.stringify({\r\n            client_time_zone: \"America/New_York\",\r\n            order_by: [],\r\n            search: [\r\n              {\r\n                column: \"exporter_search\",\r\n                value: ` ${exporterName} `,\r\n                comparison: \"like\",\r\n                data: { },\r\n                _key: `exporter_search_like_ ${exporterName} `\r\n              }\r\n            ],\r\n            query_limit: { offset: 0, max_num_rows: 50 },\r\n            hostDisplayType: \"ip\"\r\n          })\r\n        }\r\n      };\r\n    }\r\n    \r\n\r\n    };\r\n    \r\n    //params to figure out which interfaces exist for a device\r\n   \r\n  \r\n\r\n  reportJSON(scrutInfo, scrutParams) {\r\n    //returning report params to be passed into request\r\n    return {\r\n      url:scrutInfo['url'],\r\n      'method':'get',\r\n      params:{\r\n        rm: \"report_api\",\r\n        action: \"get\",\r\n        authToken: scrutInfo['authToken'],\r\n        rpt_json: JSON.stringify({\r\n          reportTypeLang: scrutParams.reportType,\r\n          reportDirections: {\r\n            selected: scrutParams.reportDirection\r\n          },\r\n          times: {\r\n            dateRange: \"Custom\",\r\n            start: `${scrutParams.startTime}`,\r\n            end: `${scrutParams.endTime}`\r\n          },\r\n          orderBy: scrutParams.scrutDisplay[\"display\"],\r\n          filters: scrutParams.scrutFilters,\r\n          dataGranularity: {\r\n            selected: \"auto\"\r\n          },\r\n          showOthers: 0\r\n        }),\r\n  \r\n        data_requested: JSON.stringify({\r\n          [scrutParams.reportDirection]: {\r\n            graph: \"all\",\r\n            table: {\r\n              query_limit: {\r\n                offset: 0,\r\n                max_num_rows: 10\r\n              }\r\n            }\r\n          }\r\n        })\r\n      }\r\n\r\n    };\r\n  }  \r\n\r\n  //function to gather forcast data. \r\n\r\n  forcastData(scrutInfo, forcastID) {\r\n    return {\r\n      url:scrutInfo['url'],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"forecasting\",\r\n        view: \"forecast_data\",\r\n        forecast_id: forcastID,\r\n        authToken: scrutInfo['authToken']\r\n      }\r\n    };\r\n  };\r\n\r\n\r\n  forecastSummary(scrutInfo, forcastID) {\r\n    return {\r\n      url:scrutInfo['url'],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"forecasting\",\r\n        view: \"summary\",\r\n        forecast_id: forcastID,\r\n        authToken: scrutInfo['authToken']\r\n      }\r\n    };\r\n  };\r\n\r\n  getForcasts(scrutInfo){\r\n    return {\r\n      url:scrutInfo['url'],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"forecasting\",\r\n        view: \"table\",\r\n        authToken: scrutInfo['authToken']\r\n      }\r\n    };\r\n  }\r\n\r\n}\r\nexport class Handledata {\r\n  //scrutinizer returns graph data opposite of how grafana wants it. So we flip it here.\r\n  constructor() {\r\n    this.rearrangeData = (arr, oldIndex, newIndex) => {\r\n      while (oldIndex < 0) {\r\n        old_index += arr.length;\r\n      }\r\n      while (newIndex < 0) {\r\n        new_index += arr.length;\r\n      }\r\n      if (newIndex >= arr.length) {\r\n        let k = newIndex - arr.length;\r\n\r\n        while (k-- + 1) {\r\n          arr.push(undefined);\r\n        }\r\n      }\r\n      arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\r\n      return arr;\r\n    };\r\n  }\r\n\r\n  formatData(scrutData, scrutParams, intervalTime, options) {\r\n\r\n    //check if DNS resolve is on. \r\n    let dnsResolve = options.reportDNS\r\n\r\n\r\n    let displayValue;\r\n\r\n    if (scrutParams.scrutDisplay[\"display\"] === \"custom_interfacepercent\") {\r\n      displayValue = \"percent\";\r\n    } else {\r\n      displayValue = \"bits\";\r\n    }\r\n\r\n    let reportDirection = scrutParams.reportDirection;\r\n    //grafana wants time in millaseconds. so we multiple by 1000.\r\n    //we also want to return data in bits, so we device by 8\r\n    let datatoGraph = [];\r\n\r\n    let graphingData = scrutData;\r\n    let i,\r\n      j = 0;\r\n    let graphData = graphingData[\"report\"][\"graph\"][\"pie\"][reportDirection];\r\n\r\n    let tableData =\r\n      graphingData[\"report\"][\"graph\"][\"timeseries\"][reportDirection];\r\n\r\n    //if user is selecting bits, we need to multiple by 8, we also need to use the interval time.\r\n    if (displayValue === \"bits\") {\r\n      for (i = 0; i < tableData.length; i++) {\r\n        for (j = 0; j < tableData[i].length; j++) {\r\n          tableData[i][j][0] = tableData[i][j][0] * 1000;\r\n          tableData[i][j][1] = (tableData[i][j][1] * 8) / (intervalTime * 60);\r\n          this.rearrangeData(tableData[i][j], 0, 1);\r\n        }\r\n      }\r\n    } else {\r\n      //since interface reporting uses the total tables, we dont need to math it.\r\n      for (i = 0; i < tableData.length; i++) {\r\n        for (j = 0; j < tableData[i].length; j++) {\r\n          tableData[i][j][0] = tableData[i][j][0] * 1000;\r\n          tableData[i][j][1] = Math.round(tableData[i][j][1]);\r\n          this.rearrangeData(tableData[i][j], 0, 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < graphData.length; i++) {\r\n\r\n      let interfaceId;\r\n      let interfaceDesc;\r\n\r\n      if (scrutParams[\"reportType\"] === \"interfaces\") {\r\n        if (scrutParams[\"reportDirection\"] === \"inbound\") {\r\n          interfaceId = \"Inbound Interface\";\r\n          interfaceDesc = \"Inbound\";\r\n        } else {\r\n          interfaceId = \"Outbound Interface\";\r\n          interfaceDesc = \"Outbound\";\r\n        }\r\n        //scrutinizer returns a small amout of \"other traffic\" for interface reporting\r\n        //this has to do with the relationship between totals and conversations.\r\n        //we don't need this data, so we toss it out. It makes it do we can use SingleStat\r\n        //and Guage visualizations for interfaces, which is nice.\r\n       \r\n        if (graphData[i][\"label\"] != \"Other\") {\r\n          //check to make sure there is utilization data for interfaces.\r\n          if(tableData[i]){\r\n            datatoGraph.push({\r\n              target:\r\n                interfaceDesc + \"--\" + graphData[i][\"tooltip\"][1][interfaceId],\r\n              datapoints: tableData[i]\r\n            });\r\n          }\r\n\r\n          \r\n        }\r\n      } else {\r\n\r\n        if(!dnsResolve) {\r\n          datatoGraph.push({\r\n            target: graphData[i][\"label\"],\r\n            datapoints: tableData[i]\r\n          });\r\n        } else {\r\n          datatoGraph.push({\r\n            target: graphData[i][\"label_dns\"],\r\n            datapoints: tableData[i]\r\n          });\r\n        }\r\n\r\n\r\n\r\n      }\r\n    }\r\n\r\n    return datatoGraph\r\n    \r\n  }\r\n\r\n  formatForcasts(forcastData, forcastSummary){\r\n\r\n              //summary data brought in from different request. \r\n              let summaryData = forcastSummary['data']['inbound_rows']\r\n\r\n              let summaryDataArray = []\r\n\r\n              summaryData.forEach((summaryRow)=>{\r\n                summaryRow.forEach((itemInSummaryRow)=>{\r\n                  let keyToCheck = Object.keys(itemInSummaryRow)\r\n                  if(![\"Rank\",\"max_forecast_time\", \"upper_bound\", \"expected_value\"].includes(keyToCheck[0])){\r\n                    let rowLabel = itemInSummaryRow[keyToCheck[0]]['label'] \r\n                    let rankValue = summaryRow[0]['Rank']['label']+ '-inbound'\r\n                    summaryDataArray.push({'rankValue':rankValue, 'rowLabel':rowLabel})\r\n\r\n                  }\r\n                })\r\n              })\r\n            \r\n              //forcast results brought in, includes all time data needed. \r\n              let forcastResults = forcastData['data']['rows']\r\n\r\n\r\n              let forcastItems = []\r\n              forcastResults.forEach(row=>{forcastItems.push(row['target'])})\r\n              //unique items conatins each row (inbound-0, inbound-1, etc)\r\n              let uniqueItems = Array.from(new Set(forcastItems))\r\n\r\n\r\n              //array to be returned, contains everything needed to graph in grafana. \r\n              let finalSummaryData = []\r\n              let testData = []\r\n \r\n              //for each unique item, create an object reporesenting upper and lower bounds, attach empty array to hold time series data to it. \r\n              uniqueItems.forEach((item)=>{\r\n\r\n                finalSummaryData.push({target:item, datapoints:[]})\r\n                finalSummaryData.push({target:item+' predicted', datapoints:[]})\r\n                finalSummaryData.push({target:item +' upper bound', datapoints:[]})\r\n                finalSummaryData.push({target:item +' lower bound', datapoints:[]})\r\n              })\r\n              \r\n\r\n              finalSummaryData.forEach((item)=>{\r\n                summaryDataArray.forEach((summaryItem)=>{\r\n                  if(item['target'].includes(summaryItem['rankValue'])){\r\n                    let replacedItem = item['target'].replace(summaryItem['rankValue'],summaryItem['rowLabel'] )\r\n\r\n                    testData.push({target:replacedItem, datapoints:item['datapoints']})\r\n                  }\r\n                })\r\n                try {\r\n                  \r\n      \r\n                  \r\n                }\r\n                catch(e) {\r\n\r\n                }\r\n                \r\n\r\n              })\r\n\r\n              //add time datapoints to the empy arrays. \r\n              finalSummaryData.forEach((item)=>{\r\n                forcastResults.forEach((forcestedItem)=>{\r\n                  let epochTime = moment(forcestedItem['intervaltime']).valueOf()\r\n                  let meanValue = parseInt(forcestedItem['mean'])\r\n                  let upperValue = parseInt(forcestedItem['conf_upper'])\r\n                  let lowerValue = parseInt(forcestedItem['conf_lower'])\r\n\r\n                  try {\r\n                    if(forcestedItem['target'] === item['target'] ){\r\n                      item['datapoints'].push([(meanValue  * 8)/60, epochTime])\r\n                      \r\n                    }else if (forcestedItem['target'] + ' upper bound'=== item['target'] && forcestedItem['record_type'] === 'forecast' ){\r\n                      item['datapoints'].push([(upperValue * 8)/60 , epochTime])\r\n                      \r\n                    } else if (forcestedItem['target'] + ' lower bound'=== item['target'] && forcestedItem['record_type'] === 'forecast' ){\r\n                      item['datapoints'].push([(lowerValue * 8)/60, epochTime])\r\n                    } else if (forcestedItem['target'] + ' predicted' === item['target'] && forcestedItem['record_type'] === 'forecast' ){\r\n                      item['datapoints'].push([(meanValue  * 8)/60, epochTime])\r\n                      \r\n                      \r\n                    }\r\n                  }\r\n                  catch(err){\r\n                    console.log(err)\r\n                  }\r\n\r\n                })\r\n              })\r\n            \r\n\r\n\r\n      \r\n\r\n\r\n\r\n\r\n              return testData\r\n \r\n              \r\n\r\n\r\n\r\n\r\n  }\r\n\r\n\r\n  formatForcastsTest(forcastData, forcastSummary){\r\n\r\n    //store relevant data from API calls into variables for use later. \r\n    let summaryData = forcastSummary['data']['inbound_rows']\r\n    let forcastResults = forcastData['data']['rows']\r\n    \r\n    //holds the LANG Key - > Forcast Regerence\r\n    let summaryDataArray = []\r\n\r\n    let finalSummaryData = []\r\n\r\n    let testData = []\r\n\r\n    //Holds all of forecast items, latter deduplicated.\r\n    let forcastItems =Array.from(new Set([]))\r\n\r\n        \r\n        \r\n    //created object with 1-inbound and the lang comparision (https)\r\n    summaryData.forEach((summaryRow)=>{\r\n      summaryRow.forEach((itemInSummaryRow)=>{\r\n        let keyToCheck = Object.keys(itemInSummaryRow)\r\n        if(![\"Rank\",\"max_forecast_time\", \"upper_bound\", \"expected_value\"].includes(keyToCheck[0])){\r\n          let rowLabel = itemInSummaryRow[keyToCheck[0]]['label'] \r\n          let rankValue = summaryRow[0]['Rank']['label']+ '-inbound'\r\n          summaryDataArray.push({'rankValue':rankValue, 'rowLabel':rowLabel})\r\n\r\n        }\r\n      })\r\n    })\r\n\r\n\r\n\r\n\r\n    forcastResults.forEach(row=>{forcastItems.push(row['target'])})\r\n    let uniqueItems = Array.from(new Set(forcastItems))\r\n\r\n\r\n\r\n    uniqueItems.forEach((item)=>{\r\n\r\n      finalSummaryData.push({target:item, datapoints:[]})\r\n\r\n    })\r\n\r\n    finalSummaryData.forEach((item)=>{\r\n      summaryDataArray.forEach((summaryItem)=>{\r\n        if(item['target'].includes(summaryItem['rankValue'])){\r\n          let replacedItem = item['target'].replace(summaryItem['rankValue'],summaryItem['rowLabel'] )\r\n\r\n          testData.push({target:replacedItem, datapoints:item['datapoints']})\r\n        }\r\n      })\r\n      try {\r\n        \r\n\r\n        \r\n      }\r\n      catch(e) {\r\n\r\n      }\r\n      \r\n\r\n    })\r\n\r\n    finalSummaryData.forEach((item)=>{\r\n      forcastResults.forEach((forcestedItem)=>{\r\n        let epochTime = moment(forcestedItem['intervaltime']).valueOf()\r\n        let meanValue = parseInt(forcestedItem['mean'])\r\n        let upperValue = parseInt(forcestedItem['conf_upper'])\r\n        let lowerValue = parseInt(forcestedItem['conf_lower'])\r\n        \r\n\r\n        if(forcestedItem['target'] ===item['target'] ){\r\n          console.log('item', item)\r\n          console.log('forcastedit', forcestedItem)\r\n          if(forcestedItem['record_type']===\"train\"){\r\n            item['datapoints'].push([(meanValue  * 8)/60, epochTime])\r\n          } else if (forcestedItem['record_type']===\"forecast\"){\r\n            item['datapoints'].push([(upperValue * 8)/60 , epochTime])\r\n            item['datapoints'].push([(lowerValue * 8)/60, epochTime])\r\n            item['datapoints'].push([(meanValue  * 8)/60, epochTime])\r\n          }\r\n          \r\n    \r\n        }\r\n        // try {\r\n        //   if(forcestedItem['target'] === item['target'] && forcestedItem['record_type'] === 'train' ){\r\n        //     item['datapoints'].push([(meanValue  * 8)/60, epochTime])\r\n            \r\n        //   }else if (forcestedItem['target'] + ' upper bound'=== item['target']){\r\n        //     item['datapoints'].push([(upperValue * 8)/60 , epochTime])\r\n        //   } else if (forcestedItem['target'] + ' lower bound'=== item['target']){\r\n        //     item['datapoints'].push([(lowerValue * 8)/60, epochTime])\r\n        //   } else if (forcestedItem['target'] + ' predicted' === item['target'] && forcestedItem['record_type'] === 'forecast' ){\r\n        //     item['datapoints'].push([(meanValue  * 8)/60, epochTime])\r\n            \r\n        //   }\r\n        // }\r\n        // catch(err){\r\n        //   console.log(err)\r\n        // }\r\n\r\n      })\r\n    })\r\n  \r\n\r\n      return testData\r\n  }\r\n\r\n  formatAllForecasts(forcastData){\r\n      //store all forcast data into an array\r\n      let forecasteData = forcastData['data']['rows']\r\n      //final list to return, objects appended on each loop. \r\n      let allForcastList = []\r\n \r\n      forecasteData.forEach((allForecasts)=>{\r\n\r\n        //create object to store ID / Text relationship. \r\n        let forcastObject = \r\n        {\r\n  \r\n        }\r\n        allForecasts.forEach((forecast)=>{\r\n\r\n                  \r\n           try {\r\n              if(forecast['type']==='forecast_id'){\r\n                \r\n                let forecastId = forecast['title'].toString()\r\n\r\n                forcastObject[\"value\"] = forecastId\r\n\r\n              }\r\n            else if(forecast['type']==='description'){\r\n              let forecastDescription = forecast['title']\r\n              forcastObject[\"text\"] = forecastDescription\r\n              allForcastList.push(forcastObject)\r\n            } else {\r\n              ;\r\n            }\r\n           } catch(err){\r\n              console.log(err)\r\n           }\r\n\r\n           \r\n\r\n\r\n           \r\n        })\r\n      })\r\n\r\n      return allForcastList\r\n  }\r\n\r\n\r\n\r\n}\r\n\r\n"]}