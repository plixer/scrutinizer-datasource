{"version":3,"sources":["../src/reportData.js"],"names":["_","ScrutinizerJSON","scrut","options","reportFilter","query","authToken","reportType","reportDirection","reportDisplay","scrutDisplay","display","startTime","unix","endTime","scrutFilters","adhocFilters","selectedGranularity","reportGranularity","Number","isInteger","parseInt","reportInterface","target","reportFilters","exporterInterface","sdfDips_0","filterJson","JSON","parse","key","hasOwnProperty","filterObject","sourceIp","length","forEach","element","index","filerCount","destIp","ports","exporterDetails","exporterIp","interfaceId","filterCount","scrutInfo","url","method","params","rm","type","exporter","action","str","defaultGroupOnTop","statusTreeEnabled","page","scrutParams","granularity","report_data","stringify","reportDirections","selected","reportTypeLang","times","dateRange","start","end","clientTimezone","filters","dataGranularity","oneCollectorRequest","ipAddress","groupName","view","session_state","exporterName","client_time_zone","order_by","search","column","value","comparison","data","_key","query_limit","offset","max_num_rows","hostDisplayType","rpt_json","orderBy","showOthers","data_requested","graph","table","Handledata","rearrangeData","arr","oldIndex","newIndex","old_index","new_index","k","push","undefined","splice","scrutData","graphGranularity","granularityChosen","dnsResolve","reportDNS","resolveDNS","graphRes","displayValue","datatoGraph","graphingData","i","j","graphData","tableData","Math","round","interfaceDesc","datapoints","formatedData","AdhocHandler","filterTypes","exporters","others","resolve","includes","filter","granularyValue","granularityTransform","othersTransform","filterType","filterKey","filterValue","showValue"],"mappings":"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","file":"reportData.js","sourcesContent":["import _ from \"lodash\";\r\n\r\n\r\nexport class ScrutinizerJSON {\r\n  constructor() {}\r\n  createFilters (scrut, options, reportFilter,query){\r\n    let {authToken} = scrut;\r\n    let {reportType, reportDirection,reportDisplay } = query\r\n    let scrutDisplay;\r\n    if (reportDisplay === \"percent\") {\r\n      scrutDisplay = { display: \"custom_interfacepercent\" };\r\n    } else {\r\n      scrutDisplay = { display: \"sum_octetdeltacount\" };\r\n    }\r\n    return {\r\n      authToken,\r\n      reportType,\r\n      startTime: options[\"range\"][\"from\"].unix(),\r\n      endTime: options[\"range\"][\"to\"].unix(),\r\n      reportDirection,\r\n      scrutDisplay,\r\n      scrutFilters : reportFilter\r\n\r\n    }\r\n\r\n  }\r\n// used for single query\r\n  createParams (scrut, options, query, adhocFilters = null) {\r\n\r\n\r\n    let selectedGranularity = query.reportGranularity\r\n\r\n    if(!Number.isInteger(parseInt(selectedGranularity))) {\r\n      selectedGranularity = 'auto'\r\n    }\r\n    \r\n    let {authToken} = scrut;\r\n    let {reportType, reportDirection,reportInterface, target, reportFilters, reportDisplay} = query\r\n    let startTime = options[\"range\"][\"from\"].unix()\r\n    let endTime = options[\"range\"][\"to\"].unix()\r\n    let scrutFilters;\r\n    let exporterInterface;\r\n    let scrutDisplay;\r\n\r\n    // if there are adhoc filters for a device group / exporter user it. Otherwise dont. \r\n    if (adhocFilters !== null) {\r\n      scrutFilters = adhocFilters\r\n    }else {\r\n      if (reportInterface === \"allInterfaces\") {\r\n        exporterInterface = \"_ALL\";\r\n      } else {\r\n        exporterInterface = reportInterface;\r\n      }\r\n  \r\n      //  if user wants all devices, then they are defualted to all interfaces\r\n      if (target === \"allExporters\") {\r\n        scrutFilters = {\r\n          sdfDips_0: `in_GROUP_ALL`\r\n        };\r\n      } else if (target === \"deviceGroup\") {\r\n        scrutFilters = {\r\n          sdfDips_0: `in_GROUP_${exporterInterface}`\r\n        };\r\n      } else {\r\n        // if user wants a specific device, they can either have ALL interfaces, or a specific interface\r\n        if (exporterInterface === \"_ALL\") {\r\n          scrutFilters = {\r\n            sdfDips_0: `in_${target}_ALL`\r\n          };\r\n        } else {\r\n          scrutFilters = {\r\n            sdfDips_0: `in_${target}_${target}-${exporterInterface}`\r\n          };\r\n        }\r\n      }\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    \r\n    if (reportFilters !== \"No Filter\") {\r\n      let filterJson = JSON.parse(reportFilters);\r\n      for (var key in filterJson) {\r\n        if (filterJson.hasOwnProperty(key)) {\r\n          if (key != \"sdfDips_0\") {\r\n            scrutFilters[key] = filterJson[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (reportDisplay === \"percent\") {\r\n      scrutDisplay = { display: \"custom_interfacepercent\" };\r\n    } else {\r\n      scrutDisplay = { display: \"sum_octetdeltacount\" };\r\n    }\r\n\r\n\r\n\r\n    return {\r\n        authToken,\r\n        reportType,\r\n        startTime,\r\n        endTime,\r\n        reportDirection,\r\n        scrutFilters,\r\n        scrutDisplay,\r\n        selectedGranularity\r\n       \r\n  \r\n      }\r\n    \r\n     \r\n\r\n\r\n  }\r\n\r\n// cused to create filter object for adhoc queries\r\ncreateAdhocFilters(filterObject) {\r\n\r\n\r\n  let reportFilters = {};\r\n\r\n  //if there are ip addres filters, add them\r\n  if (filterObject.sourceIp.length > 0) {\r\n    filterObject.sourceIp.forEach((element, index) => {\r\n      let filerCount = `sdfIps_${index}`;\r\n      reportFilters[filerCount] = `in_${element}_src`;\r\n    });\r\n  }\r\n\r\n  if (filterObject.destIp.length > 0) {\r\n    filterObject.destIp.forEach((element, index) => {\r\n      let filerCount = `sdfIps_${index}`;\r\n      reportFilters[filerCount] = `in_${element}_dst`;\r\n    });\r\n  }\r\n\r\n  if (filterObject.ports.length > 0) {\r\n    filterObject.ports.forEach((element, index) => {\r\n      let filerCount = `sdfSdPorts_${index}`;\r\n      reportFilters[filerCount] = `in_${element}_both`;\r\n    });\r\n  }\r\n  //there will always be exporter filters, add them.\r\n  filterObject.exporterDetails.forEach((element, index) => {\r\n    \r\n    let { exporterIp, interfaceId } = element;\r\n\r\n    let filterCount = `sdfDips_${index}`;\r\n    if(exporterIp === \"GROUP\"){\r\n      reportFilters[filterCount] = `in_${exporterIp}_${interfaceId}`\r\n    }else if (exporterIp === \"ALL\"){\r\n      reportFilters[filterCount] = `in_${exporterIp}_${interfaceId}`\r\n    } else if (interfaceId != \"ALL\")\r\n    {\r\n      reportFilters[filterCount] = `in_${exporterIp}_${exporterIp}-${interfaceId}`;\r\n    }else if (exporterIp != \"ALL\" && exporterIp != \"GROUP\"){\r\n      reportFilters[filterCount] = `in_${exporterIp}_${interfaceId}`\r\n    }\r\n    \r\n  });\r\n \r\n\r\n  return reportFilters;\r\n}\r\n\r\n\r\n  \r\n  authJson(scrutInfo){\r\n    return {\r\n      url: scrutInfo['url'],\r\n      method: \"GET\",\r\n      params:{\r\n        rm: \"licensing\",\r\n        authToken:scrutInfo['authToken']\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  exporterJSON(scrutInfo) {\r\n    //params to figure out which exporters are available to pick from.\r\n    return {\r\n      url: scrutInfo['url'],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"get_known_objects\",\r\n        type: \"devices\",\r\n        authToken: scrutInfo['authToken']\r\n      }\r\n    };\r\n  };\r\n\r\n  findExporter(scrutInfo, exporter) {\r\n    \r\n    return {\r\n      url: scrutInfo[\"url\"],\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"loadMap\",\r\n        action: \"search\",\r\n        str: exporter,\r\n        authToken: scrutInfo[\"authToken\"],\r\n        defaultGroupOnTop: 1,\r\n        statusTreeEnabled: 1,\r\n        page: 1\r\n      }\r\n    };\r\n  };\r\n\r\n  findtimeJSON(scrutInfo,scrutParams,query, filterObject = null) {\r\n\r\n    let selectedGranularity = query.reportGranularity\r\n    if (filterObject){\r\n      if (filterObject.granularity){\r\n        selectedGranularity = filterObject.granularity\r\n      }\r\n      \r\n    }\r\n\r\n  \r\n    if(!Number.isInteger(parseInt(selectedGranularity))) {\r\n      selectedGranularity = 'auto'\r\n    }\r\n    \r\n\r\n    //params to figure out which interval your in based on data you are requesting\r\n    return {\r\n      url:scrutInfo['url'],\r\n      method:'get',\r\n      params:{\r\n        rm: \"report_start\",\r\n        authToken: scrutInfo['authToken'],\r\n        report_data: JSON.stringify({\r\n          parse: true,\r\n          reportDirections: { selected: `${scrutParams.reportDirection}` },\r\n          reportTypeLang: `${scrutParams.reportType}`,\r\n          times: {\r\n            dateRange: \"Custom\",\r\n            start: `${scrutParams.startTime}`,\r\n            end: `${scrutParams.endTime}`,\r\n            clientTimezone: \"America/New_York\"\r\n          },\r\n          filters: scrutParams.scrutFilters,\r\n          dataGranularity: { selected: selectedGranularity },\r\n          oneCollectorRequest: false\r\n        })\r\n      },\r\n\r\n    };\r\n  };\r\n\r\n  groupJSON(url, authToken) {\r\n    return {\r\n      url,\r\n      method: \"GET\",\r\n      params: {\r\n        rm: \"get_known_objects\",\r\n        type: \"deviceGroups\",\r\n        authToken\r\n      }\r\n    };\r\n  };\r\n\r\n  interfaceJSON(scrutInfo, ipAddress) {\r\n\r\n    if(ipAddress['key'] ===\"Device Group\"){\r\n      let groupName = ipAddress['value']\r\n      return {\r\n        url: scrutInfo['url'],\r\n        method:\"get\",\r\n        \r\n\r\n        params: {\r\n          rm: \"mappingConfiguration\",\r\n          view: \"mapping_configuration\",\r\n          authToken: scrutInfo[\"authToken\"],\r\n          session_state:{\r\n            \"client_time_zone\":\"America/New_York\",\"order_by\":[],\r\n            \"search\":[\r\n              {\r\n                \"column\":\"name\",\r\n                \"value\":groupName,\r\n                \"comparison\":\"equal\",\r\n                \"data\":\r\n                  {\"filterType\":\"string\"},\"_key\":\"name_equal_Cisco\"}\r\n                ],\r\n            \"query_limit\":{\r\n              \"offset\":0,\"max_num_rows\":50},\"hostDisplayType\":\"dns\"}\r\n          }\r\n        }\r\n    } else {\r\n      let exporterName\r\n      if (ipAddress['value']) {\r\n        exporterName = ipAddress['value']\r\n      } else {\r\n        exporterName = ipAddress\r\n      }\r\n      \r\n   \r\n      return {\r\n        url: scrutInfo[\"url\"],\r\n        method: \"get\",\r\n        params: {\r\n          rm: \"status\",\r\n          action: \"get\",\r\n          view: \"topInterfaces\",\r\n          authToken: scrutInfo[\"authToken\"],\r\n          session_state: JSON.stringify({\r\n            client_time_zone: \"America/New_York\",\r\n            order_by: [],\r\n            search: [\r\n              {\r\n                column: \"exporter_search\",\r\n                value: ` ${exporterName} `,\r\n                comparison: \"like\",\r\n                data: { },\r\n                _key: `exporter_search_like_ ${exporterName} `\r\n              }\r\n            ],\r\n            query_limit: { offset: 0, max_num_rows: 50 },\r\n            hostDisplayType: \"ip\"\r\n          })\r\n        }\r\n      };\r\n    }\r\n    \r\n\r\n    };\r\n    \r\n    //params to figure out which interfaces exist for a device\r\n   \r\n  \r\n\r\n  reportJSON(scrutInfo, scrutParams, filterObject = null) {\r\n\r\n    \r\n    \r\n    let selectedGranularity = scrutParams.selectedGranularity\r\n \r\n    if (filterObject){\r\n      if (filterObject.granularity !== null){\r\n        selectedGranularity = filterObject.granularity\r\n      }\r\n      \r\n    }\r\n \r\n\r\n    //returning report params to be passed into request\r\n    return {\r\n      url:scrutInfo['url'],\r\n      'method':'get',\r\n      params:{\r\n        rm: \"report_api\",\r\n        action: \"get\",\r\n        authToken: scrutInfo['authToken'],\r\n        rpt_json: JSON.stringify({\r\n          reportTypeLang: scrutParams.reportType,\r\n          reportDirections: {\r\n            selected: scrutParams.reportDirection\r\n          },\r\n          times: {\r\n            dateRange: \"Custom\",\r\n            start: `${scrutParams.startTime}`,\r\n            end: `${scrutParams.endTime}`\r\n          },\r\n          orderBy: scrutParams.scrutDisplay[\"display\"],\r\n          filters: scrutParams.scrutFilters,\r\n          dataGranularity: {\r\n            selected: selectedGranularity\r\n          },\r\n          showOthers: 0\r\n        }),\r\n  \r\n        data_requested: JSON.stringify({\r\n          [scrutParams.reportDirection]: {\r\n            graph: \"all\",\r\n            table: {\r\n              query_limit: {\r\n                offset: 0,\r\n                max_num_rows: 10\r\n              }\r\n            }\r\n          }\r\n        })\r\n      }\r\n\r\n    };\r\n  }  \r\n\r\n}\r\nexport class Handledata {\r\n  //scrutinizer returns graph data opposite of how grafana wants it. So we flip it here.\r\n  constructor() {\r\n    this.rearrangeData = (arr, oldIndex, newIndex) => {\r\n      while (oldIndex < 0) {\r\n        old_index += arr.length;\r\n      }\r\n      while (newIndex < 0) {\r\n        new_index += arr.length;\r\n      }\r\n      if (newIndex >= arr.length) {\r\n        let k = newIndex - arr.length;\r\n\r\n        while (k-- + 1) {\r\n          arr.push(undefined);\r\n        }\r\n      }\r\n      arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\r\n      return arr;\r\n    };\r\n  }\r\n\r\n  formatData(scrutData, scrutParams, graphGranularity, options, query=null) {\r\n\r\n    let granularityChosen = graphGranularity\r\n    //check if DNS resolve is on. \r\n\r\n\r\n    let dnsResolve = options.reportDNS\r\n\r\n    if(query !== null){\r\n     \r\n    \r\n      if(query.resolveDNS !== null ){\r\n      \r\n        dnsResolve = query.resolveDNS\r\n      }\r\n    }\r\n\r\n   \r\n    let graphRes = parseInt(granularityChosen) / 60\r\n\r\n    let displayValue;\r\n\r\n  \r\n    if (scrutParams.scrutDisplay[\"display\"] === \"custom_interfacepercent\") {\r\n      displayValue = \"percent\";\r\n    } else {\r\n      displayValue = \"bits\";\r\n    }\r\n\r\n    let reportDirection = scrutParams.reportDirection;\r\n    //grafana wants time in millaseconds. so we multiple by 1000.\r\n    //we also want to return data in bits, so we device by 8\r\n    let datatoGraph = [];\r\n\r\n    let graphingData = scrutData;\r\n    let i,\r\n      j = 0;\r\n    let graphData = graphingData[\"report\"][\"graph\"][\"pie\"][reportDirection];\r\n\r\n    let tableData =\r\n      graphingData[\"report\"][\"graph\"][\"timeseries\"][reportDirection];\r\n\r\n    //if user is selecting bits, we need to multiple by 8, we also need to use the interval time.\r\n    if (displayValue === \"bits\") {\r\n      for (i = 0; i < tableData.length; i++) {\r\n        for (j = 0; j < tableData[i].length; j++) {\r\n          tableData[i][j][0] = tableData[i][j][0] * 1000;\r\n          tableData[i][j][1] = (tableData[i][j][1] * 8) / (graphRes * 60);\r\n          this.rearrangeData(tableData[i][j], 0, 1);\r\n        }\r\n      }\r\n    } else {\r\n      //since interface reporting uses the total tables, we dont need to math it.\r\n      for (i = 0; i < tableData.length; i++) {\r\n        for (j = 0; j < tableData[i].length; j++) {\r\n          tableData[i][j][0] = tableData[i][j][0] * 1000;\r\n          tableData[i][j][1] = Math.round(tableData[i][j][1]);\r\n          this.rearrangeData(tableData[i][j], 0, 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < graphData.length; i++) {\r\n\r\n      let interfaceId;\r\n      let interfaceDesc;\r\n\r\n      if (scrutParams[\"reportType\"] === \"interfaces\") {\r\n        if (scrutParams[\"reportDirection\"] === \"inbound\") {\r\n          interfaceId = \"Inbound Interface\";\r\n          interfaceDesc = \"Inbound\";\r\n        } else {\r\n          interfaceId = \"Outbound Interface\";\r\n          interfaceDesc = \"Outbound\";\r\n        }\r\n        //scrutinizer returns a small amout of \"other traffic\" for interface reporting\r\n        //this has to do with the relationship between totals and conversations.\r\n        //we don't need this data, so we toss it out. It makes it do we can use SingleStat\r\n        //and Guage visualizations for interfaces, which is nice.\r\n       \r\n        if (graphData[i][\"label\"] != \"Other\") {\r\n          //check to make sure there is utilization data for interfaces.\r\n          if(tableData[i]){\r\n            datatoGraph.push({\r\n              target:\r\n                interfaceDesc + \"--\" + graphData[i][\"tooltip\"][1][interfaceId],\r\n              datapoints: tableData[i]\r\n            });\r\n          }\r\n\r\n          \r\n        }\r\n      } else {\r\n\r\n        if(!dnsResolve) {\r\n          datatoGraph.push({\r\n            target: graphData[i][\"label\"],\r\n            datapoints: tableData[i]\r\n          });\r\n        } else {\r\n          datatoGraph.push({\r\n            target: graphData[i][\"label_dns\"],\r\n            datapoints: tableData[i]\r\n          });\r\n        }\r\n\r\n\r\n\r\n      }\r\n    }\r\n\r\n    return datatoGraph\r\n    \r\n  }\r\n\r\n  formatOthers(formatedData){\r\n\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\nexport class AdhocHandler {\r\n\r\n\r\n  createObject(query, filterTypes, filters) {\r\n\r\n\r\n\r\n\r\n    let filterObject = {\r\n      sourceIp: [],\r\n      exporterDetails: [],\r\n      exporters: [],\r\n      ports: [],\r\n      destIp: [],\r\n      others:null,\r\n      granularity:null,\r\n      resolve:null\r\n    };\r\n    \r\n    \r\n    query.adhocFilters.forEach(filter => {\r\n      if (!filterTypes.includes(filter[\"key\"])) {filterObject.exporters.push(filter[\"key\"]);} \r\n      else if (filter[\"key\"] === \"Select Granularity\"){\r\n          let granularyValue = this.granularityTransform(filter['value'])\r\n          filterObject.granularity = granularyValue} \r\n      else if (filter[\"key\"] === \"Show Others\"){\r\n          let showOthers = this.othersTransform(filter['value'])\r\n          filterObject.others = showOthers\r\n        }\r\n      else if (filter[\"key\"] === \"Resolve DNS\"){\r\n        let resolveDNS = this.othersTransform(filter['value'])\r\n        filterObject.resolve = resolveDNS\r\n      }\r\n      else{\r\n        filters.forEach(filterType => {\r\n          if (filterType[\"text\"] === filter[\"key\"]) {\r\n            let filterKey = filterType[\"value\"];\r\n            let filterValue = filter[\"value\"];\r\n            filterObject[filterKey].push(filterValue);\r\n          }\r\n         });\r\n       }\r\n    });\r\n\r\n\r\n  return filterObject\r\n  }\r\n\r\ngranularityTransform(granularity){\r\n\r\n  switch (granularity) {\r\n    case \"Auto\":\r\n      return \"auto\"\r\n    case \"1 Minute\":\r\n      return \"1\"\r\n    case \"5 Minute\":\r\n      return \"5\"\r\n    case \"30 Minute\":\r\n      return \"30\"\r\n    case \"2 Hour\":\r\n      return \"120\"\r\n    case \"12 Hour\":\r\n      return \"720\"\r\n  }\r\n}\r\n\r\n\r\nothersTransform(showValue) {\r\n  switch (showValue) {\r\n    case \"No\":\r\n      return false\r\n    case \"Yes\":\r\n      return true\r\n    }\r\n\r\n  }\r\n\r\n\r\n}\r\n"]}