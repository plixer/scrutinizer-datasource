{"version":3,"sources":["../src/datasource.js"],"names":["_","ScrutinizerJSON","Handledata","reportTypes","reportDirection","displayOptions","filterTypes","granularityOptions","entityTypes","entityRowCount","makescrutJSON","dataHandler","GenericDatasource","instanceSettings","$q","backendSrv","templateSrv","type","name","q","reportOptions","reportDirections","withCredentials","liveQuery","headers","basicAuth","length","runReport","exporters","filters","scrutInfo","url","authToken","jsonData","exporterList","others","options","numberOfQueries","datatoGraph","query","buildQueryParameters","targets","filter","t","hide","when","data","getAdhocFilters","adhocFilters","checkStart","map","filterObject","sourceIp","exporterDetails","ports","destIp","forEach","includes","push","filterType","filterKey","filterValue","Promise","resolve","reject","exporterCount","numberofExporters","adhocParams","findExporter","doRequest","then","exporterIpFound","exporter_details","results","exporter_ip","interfaceParams","interfaceJSON","interfaceList","interfaceDetails","exporterName","exporterIp","interfaceName","interfaceId","toString","interfaceID","exporterInterface","filterDrag","searchStr","reportFilter","createAdhocFilters","eachQuery","index","array","scrutParams","createFilters","params","findtimeJSON","graphGranularity","response","graphView","seconds","reportJSON","formatedData","formatData","noOthers","hideOthers","concat","apply","createParams","merged","scrutFilters","target","undefined","reportInterface","reportType","reportEntity","entityChosen","entityParams","getAllEntities","entityDataArray","rowsToReturn","isNaN","parseInt","entityArray","console","log","entity","entityId","entityLabel","entityTimeSeries","getEntityTimeseries","entityData","graphEntity","formatEntityData","sort","a","b","bytesTotal","slice","authJson","status","details","message","err","title","scope","selectedIP","ctrl","groupJSON","i","value","text","interfaceThings","rows","label","refresh","exporterJSON","datasourceRequest","replace","scopedVars","refId","report","direction","interface","reportFilters","reportDisplay","display","reportGranularity","granularity","reportEntityRows","entityRows","reportDNS","dns","key","exporterParams","interfaces","exporterResults","k","exporterToSearch","interfacesToSearch","interfaceJson","presentOptions","HandleAdhocFilters"],"mappings":"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","file":"datasource.js","sourcesContent":["import _ from \"lodash\";\r\nimport { ScrutinizerJSON, Handledata } from \"./reportData\";\r\nimport {\r\n  reportTypes,\r\n  reportDirection,\r\n  displayOptions,\r\n  filterTypes,\r\n  granularityOptions,\r\n  entityTypes,\r\n  entityRowCount\r\n} from \"./reportTypes\";\r\n\r\nlet makescrutJSON = new ScrutinizerJSON();\r\nlet dataHandler = new Handledata();\r\n\r\nexport class GenericDatasource {\r\n  constructor(instanceSettings, $q, backendSrv, templateSrv) {\r\n    this.type = instanceSettings.type;\r\n    this.name = instanceSettings.name;\r\n    this.q = $q;\r\n    this.backendSrv = backendSrv;\r\n    this.templateSrv = templateSrv;\r\n    this.reportOptions = reportTypes;\r\n    this.reportDirections = reportDirection;\r\n    this.granularityOptions = granularityOptions;\r\n    this.displayOptions = displayOptions;\r\n    this.entityTypes = entityTypes;\r\n    this.entityRowCount = entityRowCount;\r\n    this.withCredentials = instanceSettings.withCredentials;\r\n    this.liveQuery = \"\";\r\n    this.headers = { \"Content-Type\": \"application/json\" };\r\n    if (\r\n      typeof instanceSettings.basicAuth === \"string\" &&\r\n      instanceSettings.basicAuth.length > 0\r\n    ) {\r\n      this.headers[\"Authorization\"] = instanceSettings.basicAuth;\r\n    }\r\n    this.runReport = false;\r\n\r\n    this.exporters = [];\r\n    this.filterTypes = filterTypes;\r\n\r\n\r\n    this.filters = \"\";\r\n\r\n    this.scrutInfo = {\r\n      url: instanceSettings.url + \"/fcgi/scrut_fcgi.fcgi\",\r\n      authToken: instanceSettings.jsonData[\"scrutinizerKey\"]\r\n    };\r\n    this.exporterList = this.exporterList();\r\n\r\n    this.others = false\r\n  }\r\n\r\n  query(options) {\r\n\r\n    //store number of queries being run, make sure to run a Scrutinizer request for each query made.\r\n    let numberOfQueries = 0;\r\n    //data sent up into this list, it's returned at end.\r\n    let datatoGraph = [];\r\n    //only run a report if all options are populated, only matter when there are not adhoc filters.\r\n    this.runReport = false;\r\n    //takes the query and stores it to a variable\r\n    var query = this.buildQueryParameters(options);\r\n    //save the query to this, so it can be accessed by other methods.\r\n    this.liveQuery = query;\r\n    query.targets = query.targets.filter(t => !t.hide);\r\n    if (query.targets.length <= 0) {\r\n      return this.q.when({ data: [] });\r\n    }\r\n    //add adhoc filters to the query.\r\n    if (this.templateSrv.getAdhocFilters) {\r\n      query.adhocFilters = this.templateSrv.getAdhocFilters(this.name);\r\n    } else {\r\n      query.adhocFilters = [];\r\n    }\r\n\r\n    let checkStart = query.targets.length - 1;\r\n    //counter is used to keep track of number of exporters. This matters for creating the filter ojects\r\n    let filterTypes = this.filterTypes.map(filter => filter[\"text\"]);\r\n    let filterObject = {\r\n      sourceIp: [],\r\n      exporterDetails: [],\r\n      exporters: [],\r\n      ports: [],\r\n      destIp: []\r\n    };\r\n    if (query.adhocFilters.length > 0) {\r\n      query.adhocFilters.forEach(filter => {\r\n        if (!filterTypes.includes(filter[\"key\"])) {\r\n          filterObject.exporters.push(filter[\"key\"]);\r\n        } else {\r\n          this.filterTypes.forEach(filterType => {\r\n            if (filterType[\"text\"] === filter[\"key\"]) {\r\n              let filterKey = filterType[\"value\"];\r\n              let filterValue = filter[\"value\"];\r\n              filterObject[filterKey].push(filterValue);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      //this exporter count is compared to the number of exporters to verify we have loops threw everything before returning.\r\n      let exporterCount = 0;\r\n      let numberofExporters = 0;\r\n\r\n      if (query.adhocFilters.length > 0) {\r\n        query.adhocFilters.forEach(filter => {\r\n          //if there is an exporter passed in the adhoc filter.\r\n          if (\r\n            filterObject.exporters.length > 0 &&\r\n            !filterTypes.includes(filter[\"key\"])\r\n          ) {\r\n           \r\n           \r\n            numberofExporters++;\r\n\r\n            //in some cases we will be passed the DNS/SNMP name of an exporter, here we convert it to an IP address needed for final filter.\r\n            \r\n            let adhocParams = makescrutJSON.findExporter(\r\n              this.scrutInfo,\r\n              filter[\"key\"]\r\n            );\r\n\r\n            this.doRequest(adhocParams).then(exporter_details => {\r\n         \r\n              let exporterIpFound\r\n              if (exporter_details.data.results.length >0){\r\n                exporterIpFound = exporter_details.data.results[0].exporter_ip;\r\n              } else if (filter['key'] === \"All Exporters\"){\r\n                exporterIpFound = \"GROUP\"\r\n              }else if (filter['key'] === \"Device Group\") {\r\n                exporterIpFound = filter\r\n              }\r\n             \r\n\r\n              //need to find the interface ID for the interface passed to Scrutinizer.\r\n              let interfaceParams = makescrutJSON.interfaceJSON(\r\n                this.scrutInfo,\r\n                exporterIpFound\r\n              );\r\n\r\n              this.doRequest(interfaceParams).then(interfaceDetails => {\r\n                let interfaceList = interfaceDetails[\"data\"][\"rows\"];\r\n\r\n                //for each interface that belongs to a device, we want to compare it against the one selected in grafana. If it matched we can add it to the filters\r\n        \r\n                 if (filter[\"value\"] === \"All Interfaces\") {\r\n                  filterObject.exporterDetails.push({\r\n                    exporterName: filter[\"key\"],\r\n                    exporterIp: exporterIpFound,\r\n                    interfaceName: filter[\"value\"],\r\n                    interfaceId: \"ALL\"\r\n                  });\r\n                } else if(filter[\"key\"] === \"Device Group\"){\r\n                  filterObject.exporterDetails.push({\r\n                    exporterName: filter[\"key\"],\r\n                    exporterIp: \"GROUP\",\r\n                    interfaceName: filter[\"value\"],\r\n                    interfaceId: interfaceList[0][8]['id'].toString()\r\n                  })\r\n                }\r\n                else{\r\n                  interfaceList.forEach(exporterInterface => {\r\n                    let interfaceID = exporterInterface[5].filterDrag.searchStr;\r\n                    let interfaceName = exporterInterface[5][\"label\"];\r\n\r\n                    //if selected interface matches and interface in the list, add it to object\r\n                    if (filter[\"value\"] === interfaceName) {\r\n                      filterObject.exporterDetails.push({\r\n                        exporterName: filter[\"key\"],\r\n                        exporterIp: exporterIpFound,\r\n                        interfaceName: filter[\"value\"],\r\n                        interfaceId: interfaceID\r\n                      });\r\n                    }\r\n                  });\r\n                }\r\n\r\n                exporterCount++;\r\n                //we have now looped through all the exporters in the filters.\r\n                if (exporterCount === numberofExporters) {\r\n                 \r\n                  //created the filters we need to pass into each gadget on the dashboard.\r\n                  let reportFilter = makescrutJSON.createAdhocFilters(\r\n                    filterObject\r\n                  );\r\n   \r\n                  //run a query for each gadget on the dashboard.\r\n                  query.targets.forEach((eachQuery, index, array) => {\r\n\r\n                    let scrutParams = makescrutJSON.createFilters(\r\n                      this.scrutInfo,\r\n                      options,\r\n                      reportFilter,\r\n                      eachQuery\r\n                    );\r\n\r\n                    let params = makescrutJSON.findtimeJSON(\r\n                      this.scrutInfo,\r\n                      scrutParams,\r\n                      eachQuery\r\n                    );\r\n                    //find out what interval the data is in, we need to use this later to normalize the graphs.\r\n                    this.doRequest(params).then(response => {\r\n\r\n                      let graphGranularity =\r\n                      response.data[\"report_object\"].graphView.graphGranularity.seconds;        \r\n\r\n                      //set up JSON to go to Scrutinizer API\r\n                      let params = makescrutJSON.reportJSON(\r\n                        this.scrutInfo,\r\n                        scrutParams\r\n                      );\r\n                      //request for report data made to scrutinizer\r\n                      this.doRequest(params).then(response => {\r\n\r\n                        \r\n                        //data organized into how Grafana expects it.\r\n                        let formatedData = dataHandler.formatData(\r\n                          response.data,\r\n                          scrutParams,\r\n                          graphGranularity, \r\n                          query\r\n                        );\r\n\r\n                        let noOthers;\r\n                        //add ability to filter out other traffic if desired. \r\n\r\n                        if (query.hideOthers) {\r\n                          noOthers = formatedData.filter((data)=>{\r\n                            return data['target'] != 'Other'\r\n                              })\r\n                          datatoGraph.push(noOthers);\r\n                        } else {\r\n                          datatoGraph.push(formatedData);\r\n                        }\r\n                        datatoGraph = [].concat.apply([], datatoGraph);\r\n                        numberOfQueries++;\r\n                        //make sure we have gone through each query in a gadget.\r\n                        if (numberOfQueries === array.length) {\r\n\r\n                          return resolve({ data: datatoGraph });\r\n                        }\r\n                      });\r\n                    });\r\n                  });\r\n                }\r\n              });\r\n            });\r\n          }\r\n          //if there is not an exporter passed in t e filter.\r\n          else if (filterObject.exporters.length === 0) {\r\n            query.targets.forEach((query, index, array) => {\r\n              let scrutParams = makescrutJSON.createParams(\r\n                this.scrutInfo,\r\n                options,\r\n                query\r\n              );\r\n              //figure out the intervale time.\r\n              let params = makescrutJSON.findtimeJSON(\r\n                this.scrutInfo,\r\n                scrutParams,\r\n                query\r\n              );\r\n              this.doRequest(params).then(response => {\r\n               \r\n                //store interval here.\r\n\r\n                let graphGranularity =\r\n                  response.data[\"report_object\"].graphView.graphGranularity.seconds;        \r\n  \r\n                //set up JSON to go to Scrutinizer API\r\n                this.filters = makescrutJSON.createAdhocFilters(filterObject);\r\n                //add adhoc filters to exhisting filters.\r\n                let merged = {\r\n                  ...this.filters,\r\n                  ...scrutParams[\"scrutFilters\"]\r\n                };\r\n\r\n                scrutParams.scrutFilters = merged;\r\n                let params = makescrutJSON.reportJSON(\r\n                  this.scrutInfo,\r\n                  scrutParams\r\n                );\r\n                this.doRequest(params).then(response => {\r\n                  let formatedData = dataHandler.formatData(\r\n                    response.data,\r\n                    scrutParams,\r\n                    graphGranularity,\r\n                    query\r\n                  );\r\n\r\n                  let noOthers;\r\n\r\n                  //add ability to filter out other traffic if desired. \r\n                  if (query.hideOthers) {\r\n                    noOthers = formatedData.filter((data)=>{\r\n                      return data['target'] != 'Other'\r\n                        })\r\n                    datatoGraph.push(noOthers);\r\n                  } else {\r\n                    datatoGraph.push(formatedData);\r\n                  }\r\n                  datatoGraph = [].concat.apply([], datatoGraph);\r\n\r\n                  numberOfQueries++;\r\n                  //incase user has multiple queries we want to make sure we have iterated through all of them before returning results.\r\n                  if (numberOfQueries === array.length) {\r\n\r\n                    return resolve({ data: datatoGraph });\r\n                  }\r\n                });\r\n              });\r\n            });\r\n          }\r\n        });\r\n      } else {\r\n        //else block meands you don't have any adhoc filters applied.\r\n\r\n    \r\n        if (\r\n          (query.targets[checkStart].target !== undefined ||\r\n            \"Select Exporter\") &&\r\n          query.targets[checkStart].reportInterface !== \"Select Interface\" &&\r\n          query.targets[checkStart].reportDirection !== \"Select Direction\" &&\r\n          query.targets[checkStart].reportType !== \"Select Report\"\r\n        ) {\r\n          this.runReport = true;\r\n        }\r\n\r\n        if (query.targets[checkStart].target === 'entityView' && \r\n          query.targets[checkStart].reportEntity !== \"Select Entity\"){\r\n            this.runReport = true;\r\n          }\r\n  \r\n        //once all drop downs are selected, run the report.\r\n        if (this.runReport == true) {\r\n\r\n           query.targets.forEach((query, index, array) => {\r\n             \r\n              if(query.target === \"entityView\"){\r\n                \r\n                let entityChosen = query.reportEntity\r\n                let entityParams = makescrutJSON.getAllEntities(this.scrutInfo, entityChosen)\r\n                let entityDataArray = []\r\n              \r\n\r\n                this.doRequest(entityParams).then(response=>{\r\n\r\n                  let rowsToReturn = query['reportEntityRows']\r\n                  //check if user has selected number of rows, if not set it to 10. \r\n                  if (isNaN(parseInt(rowsToReturn))) {rowsToReturn = 10}\r\n                  \r\n                  //get back all of the entities from explore -> entities in Scrutinizer, story them in an array. \r\n                  let entityArray = response['data']['rows']\r\n                  console.log(entityArray)\r\n                  //got through each entitiy and get time series data for it. \r\n                  entityArray.forEach((entity)=>{\r\n                    \r\n                    //entityId is the raw name used when getting it's time series data\r\n                    let entityId = entity[0]['entity_id']\r\n                    //entity label is the text value that will be used int he grafana sisplay. \r\n                    let entityLabel = entity[0]['label']\r\n\r\n                    //params needed to get the time series for a entity. \r\n                    let entityTimeSeries = makescrutJSON.getEntityTimeseries(this.scrutInfo,entityId, options, query)\r\n   \r\n                    //make the request for each entities timeseries. \r\n                    this.doRequest(entityTimeSeries).then((entityData)=>{\r\n                          \r\n                      let graphEntity = dataHandler.formatEntityData(entityData, entityLabel, entityChosen)\r\n                      entityDataArray.push(graphEntity)\r\n\r\n                      if(entityDataArray.length >= parseInt(entityArray.length)){\r\n                        entityDataArray.sort((a,b)=>{\r\n                          return b.bytesTotal - a.bytesTotal\r\n                        })\r\n                        numberOfQueries++;\r\n                        if (numberOfQueries === array.length) {\r\n\r\n                          return resolve({ data: entityDataArray.slice(0,rowsToReturn) })\r\n                        }\r\n                      \r\n                    }\r\n                  })\r\n                  \r\n                }\r\n    \r\n                \r\n                )\r\n                \r\n              })\r\n      \r\n    \r\n              return\r\n            }\r\n\r\n\r\n            let scrutParams = makescrutJSON.createParams(\r\n              this.scrutInfo,\r\n              options,\r\n              query\r\n            );\r\n            //figure out the intervale time.\r\n            let params = makescrutJSON.findtimeJSON(\r\n\r\n              this.scrutInfo,\r\n              scrutParams,\r\n              query\r\n            );\r\n\r\n            this.doRequest(params).then(response => {\r\n              \r\n\r\n              let graphGranularity =\r\n                response.data[\"report_object\"].graphView.graphGranularity.seconds;        \r\n\r\n       \r\n              //set up JSON to go to Scrutinizer API\r\n              let params = makescrutJSON.reportJSON(\r\n                this.scrutInfo,\r\n                scrutParams\r\n              );\r\n              this.doRequest(params).then(response => {\r\n\r\n                let formatedData = dataHandler.formatData(\r\n                  response.data,\r\n                  scrutParams,\r\n                  graphGranularity,\r\n                  query,\r\n                  \r\n                );\r\n     \r\n\r\n                let noOthers;\r\n\r\n                //add ability to filter out other traffic if desired. \r\n                if (query.hideOthers) {\r\n                  noOthers = formatedData.filter((data)=>{\r\n                    return data['target'] != 'Other'\r\n                      })\r\n                  datatoGraph.push(noOthers);\r\n                } else {\r\n                  datatoGraph.push(formatedData);\r\n                }\r\n                \r\n         \r\n                datatoGraph = [].concat.apply([], datatoGraph);\r\n                \r\n                numberOfQueries++;\r\n                //incase user has multiple queries we want to make sure we have iterated through all of them before returning results.\r\n                if (numberOfQueries === array.length) {\r\n\r\n                  return resolve({ data: datatoGraph });\r\n                }\r\n              });\r\n            });\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  showOtherTraffic(){\r\n\r\n    this.others = !this.others\r\n\r\n\r\n  }\r\n\r\n  testDatasource() {\r\n\r\n    let params = makescrutJSON.authJson(this.scrutInfo);\r\n\r\n    return this.doRequest(params).then(response => {\r\n      if (response.status === 200) {\r\n        if (response.data.details == \"invalidToken\") {\r\n          //alert if authToken is expired or invalid\r\n          return {\r\n            status: \"failed\",\r\n            message: `Check your API key, recevied back: ${response.data.err}`,\r\n            title: \"Api Key Failure\"\r\n          };\r\n        } else {\r\n          //success if everything works.\r\n          return {\r\n            status: \"success\",\r\n            message: \"Data source is working\",\r\n            title: \"Success\"\r\n          };\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  findInterfaces(options, scope) {\r\n\r\n\r\n    let query = this.liveQuery;\r\n\r\n    if (query.targets) {\r\n\r\n      //determines which select you have clicked on.\r\n      let selectedIP = scope.ctrl.target.target;\r\n\r\n      if (selectedIP === \"deviceGroup\") {\r\n        let params = makescrutJSON.groupJSON(\r\n          this.scrutInfo[\"url\"],\r\n          this.scrutInfo[\"authToken\"]\r\n        );\r\n        \r\n        //if user selects Device Group we return a list of all groups available.\r\n        return this.doRequest(params).then(response => {\r\n          let i = 0;\r\n\r\n          let jsonData = response.data;\r\n          let data = [];\r\n          for (i = 0; i < jsonData.length; i++) {\r\n            data.push({\r\n              value: jsonData[i][\"id\"].toString(),\r\n              text: jsonData[i][\"name\"]\r\n            });\r\n          }\r\n\r\n          return data;\r\n        });\r\n      } else {\r\n        //otherwise we figre out what interfaces are available for selected device.\r\n        let interfaceThings = makescrutJSON.interfaceJSON(\r\n          this.scrutInfo,\r\n          selectedIP\r\n        );\r\n       \r\n \r\n        return this.doRequest(interfaceThings).then(response => {\r\n\r\n          let data = [{ text: \"All Interfaces\", value: \"allInterfaces\" }];\r\n          let i = 0;\r\n          let jsonData = response.data;\r\n\r\n          for (i = 0; i < jsonData.rows.length; i++) {\r\n            data.push({\r\n              value: jsonData.rows[i][5].filterDrag.searchStr,\r\n              text: jsonData.rows[i][5].label\r\n            });\r\n          }\r\n\r\n          return data;\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  applyFilter(scope, refresh) {\r\n\r\n    this.filters = scope.ctrl.target.filters;\r\n    refresh.refresh();\r\n  }\r\n\r\n  //gets all exporters available. Will use DNS resolve by default and fail back to IP of exporter.\r\n  getExporters() {\r\n\r\n    return this.exporters;\r\n  }\r\n\r\n  exporterList() {\r\n    let params = makescrutJSON.exporterJSON(this.scrutInfo);\r\n    return this.doRequest(params).then(response => {\r\n      let exporterList = [\r\n        { text: \"All Exporters\", value: \"allExporters\" },\r\n        { text: \"Entity Reports\", value: \"entityView\" },\r\n        { text: \"Device Group\", value: \"deviceGroup\" }\r\n      ];\r\n      for (let i = 0; i < response.data.length; i++) {\r\n        exporterList.push({\r\n          text: response.data[i][\"name\"],\r\n          value: response.data[i][\"ip\"]\r\n        });\r\n      }\r\n\r\n      this.exporters = exporterList;\r\n      return exporterList;\r\n    });\r\n  }\r\n\r\n  doRequest(options) {\r\n\r\n    options.withCredentials = this.withCredentials;\r\n    options.headers = this.headers;\r\n\r\n    return this.backendSrv.datasourceRequest(options);\r\n  }\r\n\r\n  //function from simplejsondatasource, used to take values from drop downs and add to query.\r\n  //When adding a new dropdown you need to update this function.\r\n  buildQueryParameters(options) {\r\n\r\n    options.targets = _.filter(options.targets, target => {\r\n      return target.target !== \"select metric\";\r\n    });\r\n\r\n    var targets = _.map(options.targets, target => {\r\n\r\n      return {\r\n        target: this.templateSrv.replace(\r\n          target.target,\r\n          options.scopedVars,\r\n          \"regex\"\r\n        ),\r\n        refId: target.refId,\r\n        hide: target.hide,\r\n        type: target.type || \"timeserie\",\r\n\r\n        reportType: this.templateSrv.replace(\r\n          target.report,\r\n          options.scopedVars,\r\n          \"regex\"\r\n        ),\r\n\r\n        reportDirection: this.templateSrv.replace(\r\n          target.direction,\r\n          options.scopedVars,\r\n          \"regex\"\r\n        ),\r\n\r\n        reportInterface: this.templateSrv.replace(\r\n          target.interface || \"Select Interface\",\r\n          options.scopedVars,\r\n          \"regex\"\r\n        ),\r\n\r\n        reportFilters: this.templateSrv.replace(\r\n          target.filters || \"No Filter\",\r\n          options.scopedVars,\r\n          \"regex\"\r\n        ),\r\n\r\n        reportDisplay: this.templateSrv.replace(\r\n          target.display || \"No Display\",\r\n          options.scopedVars,\r\n          \"regex\"\r\n        ),        \r\n        \r\n        reportGranularity: this.templateSrv.replace(\r\n          target.granularity || \"Select Granularity\",\r\n          options.scopedVars,\r\n          \"regex\"\r\n        ),\r\n\r\n        reportEntity: this.templateSrv.replace(\r\n          target.entity || \"Select Entity\",\r\n          options.scopedVars,\r\n          \"regex\"\r\n        ),\r\n        reportEntityRows: this.templateSrv.replace(\r\n          target.entityRows || \"Number of Results\",\r\n          options.scopedVars,\r\n          \"regex\"\r\n        ),\r\n        reportDNS: target.dns,\r\n        hideOthers:target.hideOthers\r\n      };\r\n    });\r\n\r\n    options.targets = targets;\r\n\r\n    return options;\r\n  }\r\n\r\n  //used to figure out which interfaces to show for a paritcular exporter.\r\n  HandleAdhocFilters(resolve, options) {\r\n    if (options.key !=\"Device Group\"){\r\n      let exporterParams = makescrutJSON.findExporter(\r\n        this.scrutInfo,\r\n        options.key\r\n      );\r\n      let interfaces = [{ text: \"All Interfaces\" }];\r\n\r\n      this.doRequest(exporterParams).then(exporterResults => {\r\n        let exporterIp = exporterResults[\"data\"][\"results\"][0][\"exporter_ip\"];\r\n        let interfaceParams = makescrutJSON.interfaceJSON(\r\n          this.scrutInfo,\r\n          exporterIp\r\n        );\r\n\r\n        this.doRequest(interfaceParams).then(interfaceDetails => {\r\n          let interfaceList = interfaceDetails[\"data\"][\"rows\"];\r\n\r\n          for (let k = 0; k < interfaceList.length; k++) {\r\n            let interfaceName = interfaceList[k][5][\"label\"];\r\n            interfaces.push({\r\n              text: interfaceName\r\n            });\r\n          }\r\n          return resolve(interfaces);\r\n        });\r\n      });\r\n    \r\n    }\r\n    else {\r\n      let params = makescrutJSON.groupJSON(\r\n        this.scrutInfo['url'],\r\n        this.scrutInfo[\"authToken\"]\r\n      );\r\n\r\n     //if user selects Device Group we return a list of all groups available.\r\n      this.doRequest(params).then(response => {\r\n        let i = 0;\r\n\r\n        let jsonData = response.data;\r\n        let data = [];\r\n        for (i = 0; i < jsonData.length; i++) {\r\n          data.push({\r\n            value: jsonData[i][\"id\"].toString(),\r\n            text: jsonData[i][\"name\"]\r\n          });\r\n        }\r\n\r\n        return resolve(data);\r\n    })}\r\n    \r\n  }\r\n\r\n  addInterfaces(exporterName) {\r\n    //if key is exporter there is no AND, we know we are looking for interfaces on that exporter.\r\n    let interfaces = [];\r\n    let exporterToSearch = exporterName;\r\n    let adhocParams = makescrutJSON.findExporter(\r\n      this.scrutInfo,\r\n      exporterToSearch\r\n    );\r\n    this.doRequest(adhocParams).then(exporter_details => {\r\n      let exporterIpFound = exporter_details.data.results[0].exporter_ip;\r\n      let interfacesToSearch = makescrutJSON.interfaceJSON(\r\n        this.scrutInfo,\r\n        exporterIpFound\r\n      );\r\n      this.doRequest(interfacesToSearch).then(interfaceDetails => {\r\n        let i = 0;\r\n        let interfaceJson = interfaceDetails.data;\r\n\r\n        if (interfaces.length > 0) {\r\n          interfaces = [];\r\n        }\r\n        for (i = 0; i < interfaceJson.rows.length; i++) {\r\n          //add interfaces to the interface filter options\r\n          interfaces.push(interfaceJson.rows[i][5].label);\r\n        }\r\n\r\n        return resolve(interfaces);\r\n      });\r\n    });\r\n  }\r\n  presentOptions(resolve) {\r\n    let params = makescrutJSON.exporterJSON(this.scrutInfo);\r\n    return this.doRequest(params).then(response => {\r\n      let exporterList = [\r\n        { text: \"All Exporters\" },\r\n        { text: \"Device Group\" },\r\n        { text: \"Source IP Filter\" },\r\n        { text: \"Add Port Filter\" },\r\n        { text: \"Destination IP Filter\" }\r\n      ];\r\n      for (let i = 0; i < response.data.length; i++) {\r\n        exporterList.push({\r\n          text: response.data[i][\"name\"],\r\n          value: response.data[i][\"ip\"]\r\n        });\r\n      }\r\n\r\n      this.exporters = exporterList;\r\n      return resolve(exporterList);\r\n    });\r\n  }\r\n\r\n  getTagKeys(options) {\r\n    return new Promise((resolve, reject) => {\r\n      this.presentOptions(resolve);\r\n    });\r\n  }\r\n\r\n  getTagValues(options) {\r\n\r\n\r\n  \r\n    switch (options.key) {\r\n      case \"Source IP Filter\":\r\n        return new Promise((resolve, reject) => {\r\n          resolve();\r\n        });\r\n      case \"Destination IP Filter\":\r\n            return new Promise((resolve, reject) => {\r\n              resolve();\r\n            });\r\n      case \"Add Port Filter\":\r\n            return new Promise((resolve, reject) => {\r\n              resolve();\r\n            });\r\n      case \"All Exporters\":\r\n          return new Promise((resolve, reject) => {\r\n            resolve([{'text':'All Interfaces',\r\n                      'value':'All Interfaces'}]);\r\n          });\r\n      default:\r\n        return new Promise((resolve, reject) => {\r\n          this.HandleAdhocFilters(resolve, options);\r\n        });\r\n    }\r\n  }\r\n}\r\n"]}